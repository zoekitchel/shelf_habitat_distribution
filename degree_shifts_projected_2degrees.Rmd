---
title: "2˚ Shifts"
output: html_notebook
---


This script is very similar to degree_shifts_projected, but looks at 2˚ shifts instead of 1˚shifts. 


Degree shifts

Second part of paper, if we move away from equator by 2˚ degree, how much habitat do we gain or lost

I need to look at shelf area by degrees latitude

```{r setup}
library(raster)
library(sf)
library(ncdf4)
library(rmapshaper)
library(tidyverse)
library(diptest)
library(moments)
library(viridis) #colors
library(data.table)
library(hydroTSM) #hypsometric curves
library(gridExtra)
library(maptools)
library(rgdal)
library(rgeos)
library(SpaDES)
library(rnaturalearth)
library(rnaturalearthdata)
library(ggnewscale)


etopo_shelf_df <- readRDS("~/Documents/grad school/Rutgers/Repositories/shelf_habitat_distribution/etopo_shelf_df.rds")
#bring in bathymetry data frame for shelf regions

#LMEs
LME_spdf <- readOGR("LME66/LMEs66.shp") #spatial points data frame with all 66 LMEs

#pull in shapefile for FAO statistical regions: 3/11/2021: http://www.fao.org/geonetwork/srv/en/main.home?uuid=ac02a460-da52-11dc-9d70-0017f293bd28
FAO_spdf <- readOGR("FAO_AREAS/FAO_AREAS.shp")




#convert to equal area projection
#equalareaprojection<- crs(" +proj=eqearth ")

#The Lambert azimuthal equal-area projection is a particular mapping from a sphere to a disk. It accurately represents area in all regions of the sphere, but it does not accurately represent angles.
equalareaprojection<- crs(" +proj=laea ")




```

Make bathymetry data frame into raster (this takes a bit)

Note that I am trying to use the [equal area projection](https://www.r-bloggers.com/2018/09/quick-hit-using-the-new-equal-earth-projection-in-r/)
```{r bathy to raster}

etopo_shelf_raster <- rasterFromXYZ(etopo_shelf_df, crs = crs(LME_spdf))

#reclassify all values <2000m in depth to 1 instead of actual depth
etopo_shelf_raster <- reclassify(etopo_shelf_raster,cbind(-Inf, Inf, 1))

```


Should go by projections of where species are moving:
"Marine species (~80% being ectotherms in the database; Extended Data Fig. 2) have moved towards the poles at a mean (±s.e.m.) pace of 5.92 ± 0.94 km yr−1 (one-sample Student’s t-test: t=6.26; d.f. residuals=23; P=2.20×10–6), which is almost six times faster than terrestrial species (one-way analysis of variance (ANOVA): F=12.68; d.f. factor=1; d.f. residuals=45; P=8.88×10–4)." Lenoir 2020

5.92 km * 10 = 59.2 km in 10 years

59.2 km is how many degrees?

1° = 111 km, 2˚ = 222/59.2= 3.75, so roughly 35 years
so, 

```{r quick conversion}
222/59.2

```

0.5333˚ is representative of decadal shifts, but, for better visualization let's go with 2˚ (representative of 40 year shifts)

I will put areas into 2˚ Bins (180 total degrees, so 180/2=90 total latitudinal bins)

```{r}
180/2
```

How does continental shelf habitat change with latitude?

Look at contiguous coast lines.

I am going to leave out Antarctica (61) and the Arctic (64) as Antarctica drowned out patterns in lower latitudes and Arctic doesn't have much habitat shallower than 2000m to begin with. 

NB: For subarctic regions, I'm going by [this figure](https://commons.wikimedia.org/wiki/File:IBCAO_betamap.jpg) where there appear to be splits between Europe and Greenland, Greenland and Canada, and Canada and Alaska. This is for sure up for discussion, but it seems like once species get above the continents, it is a big of a free for all. 

Eastern Atlantic (3)
-19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 58, 59, 60, 62

  3/8 update (make more LMEs serve multiple coastlines, get rid of detached islands     (New Zealand, Greenland, Iceland), and inner islands (aka Baltic Sea, mediterrraniean     sea, red sea, black sea))

  -20, 58, 57, 56, 21, 60, 22, 23* Baltic Sea, 24, 25, 27, 28, 29, 26 * Mediterranean, 62* Black Sea

Western Atlantic (2)
- 5, 6, 7, 8, 9, 12, 14, 15, 16, 17, 18, 63, 66

  -3/8 update, LEAVE OUT GREENLAND

  - 66, 55, 63** Hudson Bay, 9, 8, 7, 6, 5** GOM, 12, 17, 16, 15, 14 **what about    gulf of mexico and gulf of California?

Eastern Pacific (1)
- 1, 2, 3, 4, 11, 13, 54, 55 **Beaufort sea thinly linked to Chukchi Sea, so split here, 65

  -3/8 update
  -54, 1, 2, 53, 65, 3, 4** GOC, 11, 13

Western Indian (4)
-30, 31, 32, 33

  -3/8 update
  -30, 31, 33**black sea, 32

Eastern Indian (5)
-34, 38, 43, 44, 45


  -3/8 update
  -just use FAO statistical area 57

Western Pacific (6)
1,	35,	36,	37,	39,	40,	41,	42,	46,	47,	48,	49,	50,	51,	52,	53,	54,	56,	57,	65

  -3/8 update
  -42, 41, 50, 51, 52, 53, 1,54, 56, 57, 58, 20,and FAO statistical regions 71 and 61

Merge LMEs into 6 coastline regions

Masks for regions that are not included in LMEs (coordinates taken from Google maps). Will add in areas that do NOT overlap with existing LMEs at the end. 

```{r missing from LMEs}
#Western Pacific, include FAO statistical regions 71 and 61
west_pac_fao <- FAO_spdf[FAO_spdf$F_CODE %in% c(61,71),]

#adjust extent a bit to get rid of rogue -178 points
west_pac_fao <- crop(west_pac_fao, extent(94, 180, -28.15, 66.4148))

west_pac_fao.raster <- crop(etopo_shelf_raster, extent(94, 180, -28.15, 66.4148))
west_pac_fao.raster <- mask(west_pac_fao.raster, west_pac_fao)

#Eastern Indian Ocean
east_ind_fao <- FAO_spdf[FAO_spdf$F_CODE == 57,]


```

```{r merging LMEs}
west_pac <- c(42, 41, 50, 51, 52, 53, 1,54, 56, 57, 58, 20)
east_pac <- c(54, 1, 2, 53, 65, 3, 4, 11, 13)
west_atl <- c(66, 55, 63, 9, 8, 7, 6, 5, 12, 17, 16, 15, 14)
east_atl <- c(20, 58, 57, 56, 21, 60, 22, 23, 24, 25, 27, 28, 29, 26, 62)
west_ind <- c(30, 31, 33, 32)

#subregions based on LME_number
west_pac_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% west_pac,]
east_pac_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% east_pac,]
west_atl_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% west_atl,]
west_ind_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% west_ind,]
east_atl_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% east_atl,]
east_ind_spdf <- east_ind_fao


#rotate raster for bathymetry (guided by extent of etoposhelf raster,  that's why wacky #s)
x1 <- crop(etopo_shelf_raster, extent(-180.0167, -0.0167, -90.01667, 90.01667))
x2 <- crop(etopo_shelf_raster, extent(0, 180.0167, -90.01667, 90.01667))   
extent(x1) <- c(180.0167, 360.0167, -90.01667 , 90.01667)
etopo_shelf_raster_180 <- merge(x1, x2)

#for subregions that span 360, we need to change CRS a bit
newCRS_west <- "+proj=longlat +datum=WGS84 +lon_wrap=180" #this shifts 180 degrees
west_pac_spdf_shift <- spTransform(west_pac_spdf, CRS(newCRS_west))
west_pac_spdf_shift <- gBuffer(west_pac_spdf_shift, byid=TRUE, width=0) #gets rid of buffers, allows for union

newCRS_east <- "+proj=longlat +datum=WGS84 +lon_wrap=180" #this shifts 180 degrees
east_pac_spdf_shift <- sp::spTransform(east_pac_spdf, newCRS_east)
east_pac_spdf_shift <- gBuffer(east_pac_spdf_shift, byid=TRUE, width=0) #gets rid of buffers, allows for union

#get rid of buffer for east atl as well to allow for union

east_atl_spdf_nobuf <- gBuffer(east_atl_spdf, byid=TRUE, width=0)

region_names <- c("west_pac_spdf_shift", "east_pac_spdf_shift", "west_atl_spdf", "west_ind_spdf", "east_atl_spdf_nobuf", "east_ind_spdf")



#dissolve all polygons by region
for (i in 1:length(region_names)) {
  name <- paste0(region_names[i], "_agg")
  assign(name, gUnaryUnion(get(region_names[i]))) #dissolve polygons within coastline region into one
}

```


Extract bathymetry data from polygon only to make sure we're limiting to shelf regions above 2000 meters

```{r polygon to raster}

region_names_shift <- region_names[1:2]


region_names_noshift <- region_names[3:6]


for (i in 1:length(region_names_noshift)) {
#crop bathymetry layer to LME subset (continental shelf habitat in LMEs)
  raster_extent <-
       crop(etopo_shelf_raster, extent(get(paste0(region_names_noshift[i], "_agg"))))

#which areas of raster fall within borders?
  assign(paste0(region_names_noshift[i], "_mask"),
       mask(raster_extent, get(paste0(region_names_noshift[i], "_agg"))))
  
    assign(paste0(region_names_noshift[i], "_mask_1s"),
       reclassify(get(paste0(region_names_noshift[i], "_mask")), cbind(-Inf, Inf, 1)))

  

}
```

Rotate rasters that span pacific ocean 

```{r rotate rasters that span pacific}
#east pacific
#(guided by extent of etoposhelf raster,  that's why wacky #s)
east_pac_spdf_shift_mask_1 <- crop(east_pac_spdf_shift_mask, extent(-179.9833, -0.0167, -57.51667, 79.01667))
east_pac_spdf_shift_mask_2 <- crop(east_pac_spdf_shift_mask, extent(0, 180.0167, -57.51667, 79.01667))   
extent(east_pac_spdf_shift_mask_1) <- c(180.0167, 359.9833, -57.51667, 79.01667)
east_pac_spdf_shift_mask_180 <- merge(east_pac_spdf_shift_mask_1, east_pac_spdf_shift_mask_2)

east_pac_spdf_shift_mask_1s <- reclassify(east_pac_spdf_shift_mask_180, cbind(-Inf, Inf, 1))

#west pacific
west_pac_spdf_shift_mask_1 <- crop(west_pac_spdf_shift_mask, extent(-179.9833, -0.0167, -47.18333, 82.98333))
west_pac_spdf_shift_mask_2 <- crop(west_pac_spdf_shift_mask, extent(0, 180.0167, -47.18333, 82.98333))   
extent(west_pac_spdf_shift_mask_1) <- c(180.0167, 359.9833, -47.18333, 82.98333)
west_pac_spdf_shift_mask_180 <- merge(west_pac_spdf_shift_mask_1, west_pac_spdf_shift_mask_2)

west_pac_spdf_shift_mask_1s <- reclassify(west_pac_spdf_shift_mask_180, cbind(-Inf, Inf, 1))

```


Merge in areas unaccounted for by LMEs (Philippines, Sumatra, Papua New Guinea)

```{r merge non-LME regions}
#western pacific ocean
west_pac_spdf_mask_full <- merge(west_pac_fao.raster, west_pac_spdf_shift_mask_1s)
```


How to calculate area?

- raster::area() THIS IS WHAT WE'RE GOING WITH
Raster objects: Compute the approximate surface area of cells in an unprojected (longitude/latitude) Raster object. It is an approximation because area is computed as the height (latitudinal span) of a cell (which is constant among all cells) times the width (longitudinal span) in the (latitudinal) middle of a cell. The width is smaller at the poleward side than at the equator-ward side of a cell. This variation is greatest near the poles and the values are thus not very precise for very high latitudes. If x is a Raster* object: RasterLayer or RasterBrick. Cell values represent the size of the cell in km2, or the relative size if weights=TRUE



- raster::area() 
SpatialPolygons: Compute the area of the spatial features. Works for both planar and angular (lon/lat) coordinate reference systems. If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)

- rgeos::gArea
Returns the area of the geometry in the units of the current projection. By definition non-[MULTI]POLYGON geometries have an area of 0. The area of a POLYGON is the area of its shell less the area of any holes. Note that this value may be different from the area slot of the Polygons class as this value does not subtract the area of any holes in the geometry.


Now, we will split each coastline raster into latitudinal bins of 2˚

If these have already been done, load in from file instead of recreating because that takes some time.
```{r load in from files}
load("west_pac_shelf_areas_2degrees.Rdata")
load("west_atl_shelf_areas_2degrees.Rdata")
load("west_ind_shelf_areas_2degrees.Rdata")
load("east_pac_shelf_areas_2degrees.Rdata")
load("east_atl_shelf_areas_2degrees.Rdata")
load("east_ind_shelf_areas_2degrees.Rdata")
```


Western Pacific
```{r split raster for western pacific}
north_extent <- c(xmin(west_pac_spdf_mask_full), xmax(west_pac_spdf_mask_full), 0, ymax(west_pac_spdf_mask_full))
south_extent <- c(xmin(west_pac_spdf_mask_full), xmax(west_pac_spdf_mask_full), ymin(west_pac_spdf_mask_full), 0)

#crop west_pac raster above and below 0
west_pac_spdf_shift_agg_north <- crop(west_pac_spdf_mask_full, extent(north_extent))

west_pac_spdf_shift_agg_south <- crop(west_pac_spdf_mask_full, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for west pacific
west_pac_north_latitudes <- seq(0, ymax(west_pac_spdf_mask_full), by = 2)
west_pac_south_latitudes <- seq(0, ymin(west_pac_spdf_mask_full), by = -2)

#setup data table to populate in loop, subtracting one to allow for bins
west_pac_shelf_areas <- as.data.table(matrix(nrow = (length(west_pac_north_latitudes)-1+length(west_pac_south_latitudes)-1)))
                                      
west_pac_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area_rasterarea := as.numeric(V1)][, area_equalareaproj := as.numeric(V1)][, area_rgeos_gArea := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(west_pac_north_latitudes)-1)) {
  #setting up extent for slicing by min and max longitudes, and i to i+1 latitudes
  north_extent <- c(xmin(west_pac_spdf_mask_full), xmax(west_pac_spdf_mask_full), west_pac_north_latitudes[i], west_pac_north_latitudes[i+1])
  
  #crop raster segement based on bin extent
  segment_north <- crop(west_pac_spdf_mask_full, extent(north_extent))
  
  #populate data table with latitudinal bin
  west_pac_shelf_areas[i, "latitude_start"] <- west_pac_north_latitudes[i]
  west_pac_shelf_areas[i, "latitude_end"] <- west_pac_north_latitudes[i+1]
  
  if(all(is.na(values(segment_north)))) { #if there's no shelf area within a bin, all area = 0
    
  west_pac_shelf_areas[i, "area_equalareaproj"] <- 0
  west_pac_shelf_areas[i, "area_rasterarea"] <- 0
  west_pac_shelf_areas[i, "area_rgeos_gArea"] <- 0

  
  print(i)
    
  } else { #if there is shelf area within the bin, calculate area of slice
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_north, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_north)]
    
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster) #in km^2
    
  #populate data table with raster area
  west_pac_shelf_areas[i, "area_rasterarea"] <- segment_area_raster
    
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_north.sp <- rasterToPolygons(segment_north, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_north.sp.EA <- spTransform(segment_north.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_north.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with polygon area using raster calculation
  west_pac_shelf_areas[i, "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_north.sp.EA)/1e6
  
  #populate data table with polygon area using regeos calculation
  west_pac_shelf_areas[i, "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(west_pac_south_latitudes)-1)) {
  south_extent <- c(xmin(west_pac_spdf_mask_full), xmax(west_pac_spdf_mask_full), west_pac_south_latitudes[i+1], west_pac_south_latitudes[i]) #order= xmin, xmax, ymin, ymax)
  
  #raster segment
  segment_south <- crop(west_pac_spdf_mask_full, extent(south_extent))
  
  #add latitude bin info to data table
    west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "latitude_start"] <- west_pac_south_latitudes[i]
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "latitude_end"] <- west_pac_south_latitudes[i+1]
  
  
  if(all(is.na(values(segment_south)))) { #if there's no shelf area within a bin, meaning there's no shelf area at that latitude
    
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area_equalareaproj"] <- 0
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area_rasterarea"] <- 0
    west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area_rgeos_gArea"] <- 0
  
  print(i)
    
  } else {
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_south, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_south)]
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster)
    
  #populate data table with raster area
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area_rasterarea"] <- segment_area_raster
    
  
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_south.sp <- rasterToPolygons(segment_south, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_south.sp.EA <- spTransform(segment_south.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_south.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with area of polygon from raster::area function
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_south.sp.EA)/1e6
  
  #populate data table from rgeos area calculation for projected polygon
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#compare raster:area calculation, to equal area still using raster::area function, to rgeos::gArea function for polygons

ggplot(data = west_pac_shelf_areas) +
  geom_point(aes(x = latitude_start, y = area_rgeos_gArea), color = "purple", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_rasterarea), color = "darkgreen", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_equalareaproj), color = "red", size = 0.5) +
  labs(x=paste0("Latitude ","\u00B0","E"), y = "Area km^2") +
  theme_classic()

cor(west_pac_shelf_areas[,3:5], use = "complete.obs")

save(west_pac_shelf_areas, file = "west_pac_shelf_areas_2degrees.Rdata")
load("west_pac_shelf_areas_2degrees.Rdata")

```

Classify by percent change!!

between 1 and Inf % change = at least 2 fold increase (note I classified any change from 0 to something as NOT a significant change, should return to this conceptually)

between -0.5 and -inf % change = at least 2 fold decrease

between -0.499 and 0.999 = no significant change 

For area metric here, I used the raster::area function applied to the projected shapefile
```{r percent shift western pacific}
west_pac_shelf_areas[, percent_change := (area_rasterarea-data.table::shift(area_rasterarea, type = "lag"))/data.table::shift(area_rasterarea, type = "lag")][,area_1000s := area_rasterarea/1000]

west_pac_shelf_areas[,hemisphere := ifelse(latitude_end>0,"north","south")]

west_pac_shelf_areas[, change_above_2fold := ifelse((percent_change>=1 & percent_change<Inf), 1, ifelse(percent_change<=-0.5, -1, 0))]

west_pac_shelf_areas_highlight <- west_pac_shelf_areas[change_above_2fold != 0,]

west_pac_shelf_areas_stats <- table(west_pac_shelf_areas[,.(change_above_2fold,hemisphere)])
```

Model change for southern and northern hemisphere
```{r model northern versus southern western pacific}
#add mid latitude
west_pac_shelf_areas[,latitude_mid := abs((latitude_end+latitude_start)/2)]

west_pac_north_mod <- lm(data = west_pac_shelf_areas[hemisphere == "north"], area_rasterarea ~ latitude_mid)
summary(west_pac_north_mod)

west_pac_south_mod <- lm(data = west_pac_shelf_areas[hemisphere == "south"], area_rasterarea ~ latitude_mid)
summary(west_pac_south_mod)

```


Eastern Pacific

east_pac_spdf_shift

```{r split raster for eastern pacific}
north_extent <- c(xmin(east_pac_spdf_shift_mask_1s), xmax(east_pac_spdf_shift_mask_1s), 0, ymax(east_pac_spdf_shift_mask_1s))
south_extent <- c(xmin(east_pac_spdf_shift_mask_1s), xmax(east_pac_spdf_shift_mask_1s), ymin(east_pac_spdf_shift_mask_1s), 0)

#crop east_pac raster above and below 0
east_pac_spdf_shift_agg_north <- crop(east_pac_spdf_shift_mask_1s, extent(north_extent))

east_pac_spdf_shift_agg_south <- crop(east_pac_spdf_shift_mask_1s, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east pacific
east_pac_north_latitudes <- seq(0, ymax(east_pac_spdf_shift_mask_1s), by = 2)
east_pac_south_latitudes <- seq(0, ymin(east_pac_spdf_shift_mask_1s), by = -2)

#setup data table to populate in loop, subtracting one to allow for bins
east_pac_shelf_areas <- as.data.table(matrix(nrow = (length(east_pac_north_latitudes)-1+length(east_pac_south_latitudes)-1)))
                                      
east_pac_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area_rasterarea := as.numeric(V1)][, area_equalareaproj := as.numeric(V1)][, area_rgeos_gArea := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(east_pac_north_latitudes)-1)) {
  #setting up extent for slicing by min and max longitudes, and i to i+1 latitudes
  north_extent <- c(xmin(east_pac_spdf_shift_mask_1s), xmax(east_pac_spdf_shift_mask_1s), east_pac_north_latitudes[i], east_pac_north_latitudes[i+1])
  
  #crop raster segement based on bin extent
  segment_north <- crop(east_pac_spdf_shift_mask_1s, extent(north_extent))
  
  #populate data table with latitudinal bin
  east_pac_shelf_areas[i, "latitude_start"] <- east_pac_north_latitudes[i]
  east_pac_shelf_areas[i, "latitude_end"] <- east_pac_north_latitudes[i+1]
  
  if(all(is.na(values(segment_north)))) { #if there's no shelf area within a bin, all area = 0
    
  east_pac_shelf_areas[i, "area_equalareaproj"] <- 0
  east_pac_shelf_areas[i, "area_rasterarea"] <- 0
  east_pac_shelf_areas[i, "area_rgeos_gArea"] <- 0

  
  print(i)
    
  } else { #if there is shelf area within the bin, calculate area of slice
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_north, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_north)]
    
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster) #in km^2
    
  #populate data table with raster area
  east_pac_shelf_areas[i, "area_rasterarea"] <- segment_area_raster
    
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_north.sp <- rasterToPolygons(segment_north, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_north.sp.EA <- spTransform(segment_north.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_north.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with polygon area using raster calculation
  east_pac_shelf_areas[i, "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_north.sp.EA)/1e6
  
  #populate data table with polygon area using regeos calculation
  east_pac_shelf_areas[i, "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(east_pac_south_latitudes)-1)) {
  south_extent <- c(xmin(east_pac_spdf_shift_mask_1s), xmax(east_pac_spdf_shift_mask_1s), east_pac_south_latitudes[i+1], east_pac_south_latitudes[i]) #order= xmin, xmax, ymin, ymax)
  
  #raster segment
  segment_south <- crop(east_pac_spdf_shift_mask_1s, extent(south_extent))
  
  #add latitude bin info to data table
    east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "latitude_start"] <- east_pac_south_latitudes[i]
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "latitude_end"] <- east_pac_south_latitudes[i+1]
  
  
  if(all(is.na(values(segment_south)))) { #if there's no shelf area within a bin, meaning there's no shelf area at that latitude

  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area_equalareaproj"] <- 0
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area_rasterarea"] <- 0
    east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area_rgeos_gArea"] <- 0
  
  print(i)
    
  } else {
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_south, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_south)]
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster)
    
  #populate data table with raster area
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area_rasterarea"] <- segment_area_raster
    
  
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_south.sp <- rasterToPolygons(segment_south, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_south.sp.EA <- spTransform(segment_south.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_south.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with area of polygon from raster::area function
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_south.sp.EA)/1e6
  
  #populate data table from rgeos area calculation for projected polygon
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#compare raster:area calculation, to equal area still using raster::area function, to rgeos::gArea function for polygons

ggplot(data = east_pac_shelf_areas) +
  geom_point(aes(x = latitude_start, y = area_rgeos_gArea), color = "purple", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_rasterarea), color = "darkgreen", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_equalareaproj), color = "red", size = 0.5) +
  labs(x=paste0("Latitude ","\u00B0","E"), y = "Area km^2") +
  theme_classic()

cor(east_pac_shelf_areas[,3:5], use = "complete.obs")

save(east_pac_shelf_areas, file = "east_pac_shelf_areas_2degrees.Rdata")

```

```{r percent shift eastern pacific}
east_pac_shelf_areas[, percent_change := (area_rasterarea-data.table::shift(area_rasterarea, type = "lag"))/data.table::shift(area_rasterarea, type = "lag")][,area_1000s := area_rasterarea/1000]

east_pac_shelf_areas[,hemisphere := ifelse(latitude_end>0,"north","south")]

east_pac_shelf_areas[, change_above_2fold := ifelse((percent_change>=1 & percent_change<Inf), 1, ifelse(percent_change<=-0.5, -1, 0))]

east_pac_shelf_areas_highlight <- east_pac_shelf_areas[change_above_2fold != 0,]

east_pac_shelf_areas_stats <- table(east_pac_shelf_areas[,.(change_above_2fold, hemisphere)])
```

Model change for southern and northern hemisphere
```{r model northern versus southern eastern pacific}
#add mid latitude
east_pac_shelf_areas[,latitude_mid := abs((latitude_end+latitude_start)/2)]

east_pac_north_mod <- lm(data = east_pac_shelf_areas[hemisphere == "north"], area_rasterarea ~ latitude_mid)
summary(east_pac_north_mod)

east_pac_south_mod <- lm(data = east_pac_shelf_areas[hemisphere == "south"], area_rasterarea ~ latitude_mid)
summary(east_pac_south_mod)
```

Western Atlantic

west_atl_spdf_mask

```{r split raster for western atlantic}
north_extent <- c(xmin(west_atl_spdf_mask_1s), xmax(west_atl_spdf_mask_1s), 0, ymax(west_atl_spdf_mask_1s))
south_extent <- c(xmin(west_atl_spdf_mask_1s), xmax(west_atl_spdf_mask_1s), ymin(west_atl_spdf_mask_1s), 0)

#crop west_atl raster above and below 0
west_atl_spdf_shift_agg_north <- crop(west_atl_spdf_mask_1s, extent(north_extent))

west_atl_spdf_shift_agg_south <- crop(west_atl_spdf_mask_1s, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for west atlantic
west_atl_north_latitudes <- seq(0, ymax(west_atl_spdf_mask_1s), by = 2)
west_atl_south_latitudes <- seq(0, ymin(west_atl_spdf_mask_1s), by = -2)

#setup data table to populate in loop, subtracting one to allow for bins
west_atl_shelf_areas <- as.data.table(matrix(nrow = (length(west_atl_north_latitudes)-1+length(west_atl_south_latitudes)-1)))
                                      
west_atl_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area_rasterarea := as.numeric(V1)][, area_equalareaproj := as.numeric(V1)][, area_rgeos_gArea := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(west_atl_north_latitudes)-1)) {
  #setting up extent for slicing by min and max longitudes, and i to i+1 latitudes
  north_extent <- c(xmin(west_atl_spdf_mask_1s), xmax(west_atl_spdf_mask_1s), west_atl_north_latitudes[i], west_atl_north_latitudes[i+1])
  
  #crop raster segement based on bin extent
  segment_north <- crop(west_atl_spdf_mask_1s, extent(north_extent))
  
  #populate data table with latitudinal bin
  west_atl_shelf_areas[i, "latitude_start"] <- west_atl_north_latitudes[i]
  west_atl_shelf_areas[i, "latitude_end"] <- west_atl_north_latitudes[i+1]
  
  if(all(is.na(values(segment_north)))) { #if there's no shelf area within a bin, all area = 0
    
  west_atl_shelf_areas[i, "area_equalareaproj"] <- 0
  west_atl_shelf_areas[i, "area_rasterarea"] <- 0
  west_atl_shelf_areas[i, "area_rgeos_gArea"] <- 0

  print(i)
    
  } else { #if there is shelf area within the bin, calculate area of slice
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_north, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_north)]
    
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster) #in km^2
    
  #populate data table with raster area
  west_atl_shelf_areas[i, "area_rasterarea"] <- segment_area_raster
    
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_north.sp <- rasterToPolygons(segment_north, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_north.sp.EA <- spTransform(segment_north.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_north.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with polygon area using raster calculation
  west_atl_shelf_areas[i, "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_north.sp.EA)/1e6
  
  #populate data table with polygon area using regeos calculation
  west_atl_shelf_areas[i, "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(west_atl_south_latitudes)-1)) {
  south_extent <- c(xmin(west_atl_spdf_mask_1s), xmax(west_atl_spdf_mask_1s), west_atl_south_latitudes[i+1], west_atl_south_latitudes[i]) #order= xmin, xmax, ymin, ymax)
  
  #raster segment
  segment_south <- crop(west_atl_spdf_mask_1s, extent(south_extent))
  
  #add latitude bin info to data table
    west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "latitude_start"] <- west_atl_south_latitudes[i]
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "latitude_end"] <- west_atl_south_latitudes[i+1]
  
  
  if(all(is.na(values(segment_south)))) { #if there's no shelf area within a bin, meaning there's no shelf area at that latitude

  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area_equalareaproj"] <- 0
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area_rasterarea"] <- 0
    west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area_rgeos_gArea"] <- 0
  
  print(i)
    
  } else {
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_south, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_south)]
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster)
    
  #populate data table with raster area
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area_rasterarea"] <- segment_area_raster
    
  
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_south.sp <- rasterToPolygons(segment_south, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_south.sp.EA <- spTransform(segment_south.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_south.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with area of polygon from raster::area function
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_south.sp.EA)/1e6
  
  #populate data table from rgeos area calculation for projected polygon
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#compare raster:area calculation, to equal area still using raster::area function, to rgeos::gArea function for polygons

ggplot(data = west_atl_shelf_areas) +
  geom_point(aes(x = latitude_start, y = area_rgeos_gArea), color = "purple", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_rasterarea), color = "darkgreen", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_equalareaproj), color = "red", size = 0.5) +
  labs(x=paste0("Latitude ","\u00B0","E"), y = "Area km^2") +
  theme_classic()

cor(west_atl_shelf_areas[,3:5], use = "complete.obs")

```

```{r percent shift western atlantic}
west_atl_shelf_areas[, percent_change := (area_rasterarea-data.table::shift(area_rasterarea, type = "lag"))/data.table::shift(area_rasterarea, type = "lag")][,area_1000s := area_rasterarea/1000]

west_atl_shelf_areas[,hemisphere := ifelse(latitude_end>0,"north","south")]

west_atl_shelf_areas[, change_above_2fold := ifelse((percent_change>=1 & percent_change<Inf), 1, ifelse(percent_change<=-0.5, -1, 0))]

west_atl_shelf_areas_highlight <- west_atl_shelf_areas[change_above_2fold != 0,]

west_atl_shelf_areas_stats <- table(west_atl_shelf_areas[,.(change_above_2fold, hemisphere)])
```

Model change for southern and northern hemisphere
```{r model northern versus southern western atlantic}
#add mid latitude
west_atl_shelf_areas[,latitude_mid := abs((latitude_end+latitude_start)/2)]

west_atl_north_mod <- lm(data = west_atl_shelf_areas[hemisphere == "north"], area_rasterarea ~ latitude_mid)
summary(west_atl_north_mod)

west_atl_south_mod <- lm(data = west_atl_shelf_areas[hemisphere == "south"], area_rasterarea ~ latitude_mid)
summary(west_atl_south_mod)
```

Eastern Atlantic

east_atl_spdf_nobuf_mask

```{r split raster for eastern atlantic}
north_extent <- c(xmin(east_atl_spdf_nobuf_mask_1s), xmax(east_atl_spdf_nobuf_mask_1s), 0, ymax(east_atl_spdf_nobuf_mask_1s))
south_extent <- c(xmin(east_atl_spdf_nobuf_mask_1s), xmax(east_atl_spdf_nobuf_mask_1s), ymin(east_atl_spdf_nobuf_mask_1s), 0)

#crop east_atl raster above and below 0
east_atl_spdf_shift_agg_north <- crop(east_atl_spdf_nobuf_mask_1s, extent(north_extent))

east_atl_spdf_shift_agg_south <- crop(east_atl_spdf_nobuf_mask_1s, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east atlantic
east_atl_north_latitudes <- seq(0, ymax(east_atl_spdf_nobuf_mask_1s), by = 2)
east_atl_south_latitudes <- seq(0, ymin(east_atl_spdf_nobuf_mask_1s), by = -2)

#setup data table to populate in loop, subtracting one to allow for bins
east_atl_shelf_areas <- as.data.table(matrix(nrow = (length(east_atl_north_latitudes)-1+length(east_atl_south_latitudes)-1)))
                                      
east_atl_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area_rasterarea := as.numeric(V1)][, area_equalareaproj := as.numeric(V1)][, area_rgeos_gArea := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(east_atl_north_latitudes)-1)) {
  #setting up extent for slicing by min and max longitudes, and i to i+1 latitudes
  north_extent <- c(xmin(east_atl_spdf_nobuf_mask_1s), xmax(east_atl_spdf_nobuf_mask_1s), east_atl_north_latitudes[i], east_atl_north_latitudes[i+1])
  
  #crop raster segement based on bin extent
  segment_north <- crop(east_atl_spdf_nobuf_mask_1s, extent(north_extent))
  
  #populate data table with latitudinal bin
  east_atl_shelf_areas[i, "latitude_start"] <- east_atl_north_latitudes[i]
  east_atl_shelf_areas[i, "latitude_end"] <- east_atl_north_latitudes[i+1]
  
  if(all(is.na(values(segment_north)))) { #if there's no shelf area within a bin, all area = 0
    
  east_atl_shelf_areas[i, "area_equalareaproj"] <- 0
  east_atl_shelf_areas[i, "area_rasterarea"] <- 0
  east_atl_shelf_areas[i, "area_rgeos_gArea"] <- 0

  
  print(i)
    
  } else { #if there is shelf area within the bin, calculate area of slice
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_north, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_north)]
    
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster) #in km^2
    
  #populate data table with raster area
  east_atl_shelf_areas[i, "area_rasterarea"] <- segment_area_raster
    
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_north.sp <- rasterToPolygons(segment_north, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_north.sp.EA <- spTransform(segment_north.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_north.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with polygon area using raster calculation
  east_atl_shelf_areas[i, "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_north.sp.EA)/1e6
  
  #populate data table with polygon area using regeos calculation
  east_atl_shelf_areas[i, "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(east_atl_south_latitudes)-1)) {
  south_extent <- c(xmin(east_atl_spdf_nobuf_mask_1s), xmax(east_atl_spdf_nobuf_mask_1s), east_atl_south_latitudes[i+1], east_atl_south_latitudes[i]) #order= xmin, xmax, ymin, ymax)
  
  #raster segment
  segment_south <- crop(east_atl_spdf_nobuf_mask_1s, extent(south_extent))
  
  #add latitude bin info to data table
    east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "latitude_start"] <- east_atl_south_latitudes[i]
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "latitude_end"] <- east_atl_south_latitudes[i+1]
  
  
  if(all(is.na(values(segment_south)))) { #if there's no shelf area within a bin, meaning there's no shelf area at that latitude

  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area_equalareaproj"] <- 0
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area_rasterarea"] <- 0
    east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area_rgeos_gArea"] <- 0
  
  print(i)
    
  } else {
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_south, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_south)]
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster)
    
  #populate data table with raster area
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area_rasterarea"] <- segment_area_raster
    
  
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_south.sp <- rasterToPolygons(segment_south, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_south.sp.EA <- spTransform(segment_south.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_south.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with area of polygon from raster::area function
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_south.sp.EA)/1e6
  
  #populate data table from rgeos area calculation for projected polygon
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#compare raster:area calculation, to equal area still using raster::area function, to rgeos::gArea function for polygons

ggplot(data = east_atl_shelf_areas) +
  geom_point(aes(x = latitude_start, y = area_rgeos_gArea), color = "purple", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_rasterarea), color = "darkgreen", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_equalareaproj), color = "red", size = 0.5) +
  labs(x=paste0("Latitude ","\u00B0","E"), y = "Area km^2") +
  theme_classic()

cor(east_atl_shelf_areas[,3:5], use = "complete.obs")

```

```{r percent shift eastern atlantic}
east_atl_shelf_areas[, percent_change := (area_rasterarea-data.table::shift(area_rasterarea, type = "lag"))/data.table::shift(area_rasterarea, type = "lag")][,area_1000s := area_rasterarea/1000]

east_atl_shelf_areas[,hemisphere := ifelse(latitude_end>0,"north","south")]

east_atl_shelf_areas[, change_above_2fold := ifelse((percent_change>=1 & percent_change<Inf), 1, ifelse(percent_change<=-0.5, -1, 0))]

east_atl_shelf_areas_highlight <- east_atl_shelf_areas[change_above_2fold != 0,]

east_atl_shelf_areas_stats <- table(east_atl_shelf_areas[,.(change_above_2fold, hemisphere)])
```

Model change for southern and northern hemisphere
```{r model northern versus southern eastern atlantic}
#add mid latitude
east_atl_shelf_areas[,latitude_mid := abs((latitude_end+latitude_start)/2)]

east_atl_north_mod <- lm(data = east_atl_shelf_areas[hemisphere == "north"], area_rasterarea ~ latitude_mid)
summary(east_atl_north_mod)

east_atl_south_mod <- lm(data = east_atl_shelf_areas[hemisphere == "south"], area_rasterarea ~ latitude_mid)
summary(east_atl_south_mod)
```

Western Indian

west_ind_spdf_mask

```{r split raster for western indian}
north_extent <- c(xmin(west_ind_spdf_mask_1s), xmax(west_ind_spdf_mask_1s), 0, ymax(west_ind_spdf_mask_1s))
south_extent <- c(xmin(west_ind_spdf_mask_1s), xmax(west_ind_spdf_mask_1s), ymin(west_ind_spdf_mask_1s), 0)

#crop west_ind raster above and below 0
west_ind_spdf_shift_agg_north <- crop(west_ind_spdf_mask_1s, extent(north_extent))

west_ind_spdf_shift_agg_south <- crop(west_ind_spdf_mask_1s, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for west indian
west_ind_north_latitudes <- seq(0, ymax(west_ind_spdf_mask_1s), by = 2)
west_ind_south_latitudes <- seq(0, ymin(west_ind_spdf_mask_1s), by = -2)

#setup data table to populate in loop, subtracting one to allow for bins
west_ind_shelf_areas <- as.data.table(matrix(nrow = (length(west_ind_north_latitudes)-1+length(west_ind_south_latitudes)-1)))
                                      
west_ind_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area_rasterarea := as.numeric(V1)][, area_equalareaproj := as.numeric(V1)][, area_rgeos_gArea := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(west_ind_north_latitudes)-1)) {
  #setting up extent for slicing by min and max longitudes, and i to i+1 latitudes
  north_extent <- c(xmin(west_ind_spdf_mask_1s), xmax(west_ind_spdf_mask_1s), west_ind_north_latitudes[i], west_ind_north_latitudes[i+1])
  
  #crop raster segement based on bin extent
  segment_north <- crop(west_ind_spdf_mask_1s, extent(north_extent))
  
  #populate data table with latitudinal bin
  west_ind_shelf_areas[i, "latitude_start"] <- west_ind_north_latitudes[i]
  west_ind_shelf_areas[i, "latitude_end"] <- west_ind_north_latitudes[i+1]
  
  if(all(is.na(values(segment_north)))) { #if there's no shelf area within a bin, all area = 0
    
  west_ind_shelf_areas[i, "area_equalareaproj"] <- 0
  west_ind_shelf_areas[i, "area_rasterarea"] <- 0
  west_ind_shelf_areas[i, "area_rgeos_gArea"] <- 0

  
  print(i)
    
  } else { #if there is shelf area within the bin, calculate area of slice
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_north, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_north)]
    
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster) #in km^2
    
  #populate data table with raster area
  west_ind_shelf_areas[i, "area_rasterarea"] <- segment_area_raster
    
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_north.sp <- rasterToPolygons(segment_north, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_north.sp.EA <- spTransform(segment_north.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_north.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with polygon area using raster calculation
  west_ind_shelf_areas[i, "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_north.sp.EA)/1e6
  
  #populate data table with polygon area using regeos calculation
  west_ind_shelf_areas[i, "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(west_ind_south_latitudes)-1)) {
  south_extent <- c(xmin(west_ind_spdf_mask_1s), xmax(west_ind_spdf_mask_1s), west_ind_south_latitudes[i+1], west_ind_south_latitudes[i]) #order= xmin, xmax, ymin, ymax)
  
  #raster segment
  segment_south <- crop(west_ind_spdf_mask_1s, extent(south_extent))
  
  #add latitude bin info to data table
    west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "latitude_start"] <- west_ind_south_latitudes[i]
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "latitude_end"] <- west_ind_south_latitudes[i+1]
  
  
  if(all(is.na(values(segment_south)))) { #if there's no shelf area within a bin, meaning there's no shelf area at that latitude

  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area_equalareaproj"] <- 0
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area_rasterarea"] <- 0
    west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area_rgeos_gArea"] <- 0
  
  print(i)
    
  } else {
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_south, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_south)]
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster)
    
  #populate data table with raster area
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area_rasterarea"] <- segment_area_raster
    
  
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_south.sp <- rasterToPolygons(segment_south, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_south.sp.EA <- spTransform(segment_south.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_south.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with area of polygon from raster::area function
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_south.sp.EA)/1e6
  
  #populate data table from rgeos area calculation for projected polygon
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#compare raster:area calculation, to equal area still using raster::area function, to rgeos::gArea function for polygons

ggplot(data = west_ind_shelf_areas) +
  geom_point(aes(x = latitude_start, y = area_rgeos_gArea), color = "purple", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_rasterarea), color = "darkgreen", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_equalareaproj), color = "red", size = 0.5) +
  labs(x=paste0("Latitude ","\u00B0","E"), y = "Area km^2") +
  theme_classic()

cor(west_ind_shelf_areas[,3:5], use = "complete.obs")
```

```{r percent shift western indian}
west_ind_shelf_areas[, percent_change := (area_rasterarea-data.table::shift(area_rasterarea, type = "lag"))/data.table::shift(area_rasterarea, type = "lag")][,area_1000s := area_rasterarea/1000]

west_ind_shelf_areas[,hemisphere := ifelse(latitude_end>0,"north","south")]

west_ind_shelf_areas[, change_above_2fold := ifelse((percent_change>=1 & percent_change<Inf), 1, ifelse(percent_change<=-0.5, -1, 0))]

west_ind_shelf_areas_highlight <- west_ind_shelf_areas[change_above_2fold != 0,]

west_ind_shelf_areas_stats <- table(west_ind_shelf_areas[,.(change_above_2fold, hemisphere)])
```

Model change for southern and northern hemisphere
```{r model northern versus southern western indian}
#add mid latitude
west_ind_shelf_areas[,latitude_mid := abs((latitude_end+latitude_start)/2)]

west_ind_north_mod <- lm(data = west_ind_shelf_areas[hemisphere == "north"], area_rasterarea ~ latitude_mid)
summary(west_ind_north_mod)

west_ind_south_mod <- lm(data = west_ind_shelf_areas[hemisphere == "south"], area_rasterarea ~ latitude_mid)
summary(west_ind_south_mod)
```

Eastern Indian

east_ind_spdf_mask_1s

```{r split raster for eastern indian}
north_extent <- c(xmin(east_ind_spdf_mask_1s), xmax(east_ind_spdf_mask_1s), 0, ymax(east_ind_spdf_mask_1s))
south_extent <- c(xmin(east_ind_spdf_mask_1s), xmax(east_ind_spdf_mask_1s), ymin(east_ind_spdf_mask_1s), 0)

#crop east_ind raster above and below 0
east_ind_spdf_shift_agg_north <- crop(east_ind_spdf_mask_1s, extent(north_extent))

east_ind_spdf_shift_agg_south <- crop(east_ind_spdf_mask_1s, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east indian
east_ind_north_latitudes <- seq(0, ymax(east_ind_spdf_mask_1s), by = 2)
east_ind_south_latitudes <- seq(0, ymin(east_ind_spdf_mask_1s), by = -2)

#setup data table to populate in loop, subtracting one to allow for bins
east_ind_shelf_areas <- as.data.table(matrix(nrow = (length(east_ind_north_latitudes)-1+length(east_ind_south_latitudes)-1)))
                                      
east_ind_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area_rasterarea := as.numeric(V1)][, area_equalareaproj := as.numeric(V1)][, area_rgeos_gArea := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(east_ind_north_latitudes)-1)) {
  #setting up extent for slicing by min and max longitudes, and i to i+1 latitudes
  north_extent <- c(xmin(east_ind_spdf_mask_1s), xmax(east_ind_spdf_mask_1s), east_ind_north_latitudes[i], east_ind_north_latitudes[i+1])
  
  #crop raster segement based on bin extent
  segment_north <- crop(east_ind_spdf_mask_1s, extent(north_extent))
  
  #populate data table with latitudinal bin
  east_ind_shelf_areas[i, "latitude_start"] <- east_ind_north_latitudes[i]
  east_ind_shelf_areas[i, "latitude_end"] <- east_ind_north_latitudes[i+1]
  
  if(all(is.na(values(segment_north)))) { #if there's no shelf area within a bin, all area = 0
    
  east_ind_shelf_areas[i, "area_equalareaproj"] <- 0
  east_ind_shelf_areas[i, "area_rasterarea"] <- 0
  east_ind_shelf_areas[i, "area_rgeos_gArea"] <- 0

  
  print(i)
    
  } else { #if there is shelf area within the bin, calculate area of slice
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_north, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_north)]
    
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster) #in km^2
    
  #populate data table with raster area
  east_ind_shelf_areas[i, "area_rasterarea"] <- segment_area_raster
    
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_north.sp <- rasterToPolygons(segment_north, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_north.sp.EA <- spTransform(segment_north.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_north.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with polygon area using raster calculation
  east_ind_shelf_areas[i, "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_north.sp.EA)/1e6
  
  #populate data table with polygon area using regeos calculation
  east_ind_shelf_areas[i, "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(east_ind_south_latitudes)-1)) {
  south_extent <- c(xmin(east_ind_spdf_mask_1s), xmax(east_ind_spdf_mask_1s), east_ind_south_latitudes[i+1], east_ind_south_latitudes[i]) #order= xmin, xmax, ymin, ymax)
  
  #raster segment
  segment_south <- crop(east_ind_spdf_mask_1s, extent(south_extent))
  
  #add latitude bin info to data table
    east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "latitude_start"] <- east_ind_south_latitudes[i]
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "latitude_end"] <- east_ind_south_latitudes[i+1]
  
  
  if(all(is.na(values(segment_south)))) { #if there's no shelf area within a bin, meaning there's no shelf area at that latitude

  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area_equalareaproj"] <- 0
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area_rasterarea"] <- 0
    east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area_rgeos_gArea"] <- 0
  
  print(i)
    
  } else {
  
    #raster area calculation
      #get sizes of all cells in raster [km2]
    cell_size_raster<-area(segment_south, na.rm=TRUE, weights=FALSE)
    
    #delete NAs from vector of all raster cells
    cell_size_raster<-cell_size_raster[!is.na(segment_south)]
    #compute area of all cells in geo_raster
    #full area          <- total # grid cells     * median cell area (using median cares less about extreme values)
    segment_area_raster <- length(cell_size_raster)*median(cell_size_raster)
    
  #populate data table with raster area
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area_rasterarea"] <- segment_area_raster
    
  
  #convert to spatial polygons to check area calculations
    
  #convert segment from raster to polygon, each cell from the raster is an independent polygon, (dissolve means all cells with a value of 1 are a single polygon if connected)
  segment_south.sp <- rasterToPolygons(segment_south, dissolve = T)
  
  #  If x is a SpatialPolygons* object: area of each spatial object in squared meters if the CRS is longitude/latitude, or in squared map units (typically meter)
  
    #project to equal earth area projection
  segment_south.sp.EA <- spTransform(segment_south.sp, CRSobj = equalareaprojection)

  #calculate area of the spatial object in m^2
    polygon_size.sp <- area(segment_south.sp.EA)

    #convert from m^2 to km^2
    segment_area_equalarea <- polygon_size.sp/1e6

    #populate data table with area of polygon from raster::area function
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area_equalareaproj"] <- segment_area_equalarea
  
  #and then plain and simple also using rgeos::gArea
  
  area_rgeos_gArea <- gArea(segment_south.sp.EA)/1e6
  
  #populate data table from rgeos area calculation for projected polygon
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area_rgeos_gArea"] <-   area_rgeos_gArea
  
  print(i)
  } 
}

#compare raster:area calculation, to equal area still using raster::area function, to rgeos::gArea function for polygons

ggplot(data = east_ind_shelf_areas) +
  geom_point(aes(x = latitude_start, y = area_rgeos_gArea), color = "purple", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_rasterarea), color = "darkgreen", size = 0.5) +
  geom_point(aes(x = latitude_start, y = area_equalareaproj), color = "red", size = 0.5) +
  labs(x=paste0("Latitude ","\u00B0","E"), y = "Area km^2") +
  theme_classic()

cor(east_ind_shelf_areas[,3:5], use = "complete.obs")

```

```{r percent shift eastern indian}
east_ind_shelf_areas[, percent_change := (area_rasterarea-data.table::shift(area_rasterarea, type = "lag"))/data.table::shift(area_rasterarea, type = "lag")][,area_1000s := area_rasterarea/1000]

east_ind_shelf_areas[,hemisphere := ifelse(latitude_end>0,"north","south")]

east_ind_shelf_areas[, change_above_2fold := ifelse((percent_change>=1 & percent_change<Inf), 1, ifelse(percent_change<=-0.5, -1, 0))]

east_ind_shelf_areas_highlight <- east_ind_shelf_areas[change_above_2fold != 0,]

east_ind_shelf_areas_stats <- table(east_ind_shelf_areas[,.(change_above_2fold,hemisphere)])
```

Model change for southern and northern hemisphere
```{r model northern versus southern eastern indian}
#add mid latitude
east_ind_shelf_areas[,latitude_mid := abs((latitude_end+latitude_start)/2)]

east_ind_north_mod <- lm(data = east_ind_shelf_areas[hemisphere == "north"], area_rasterarea ~ latitude_mid)
summary(east_ind_north_mod)

east_ind_south_mod <- lm(data = east_ind_shelf_areas[hemisphere == "south"], area_rasterarea ~ latitude_mid)
summary(east_ind_south_mod)
```


Plots of latitude versus habitat availability

Include trend lines only for those with significant coefficients between latitude start and area^2
NOT:
- East Indian Southern and Northern
- East Pacific Southern
- West Indian Southern

```{r plots latitude habitat availability}
##east indian
#simulate data to plot trendline
east_ind_north_data <- data.table(latitude_mid = unique(east_ind_shelf_areas[latitude_end>0,]$latitude_mid))

east_ind_north_data[,area_1000s := east_ind_north_mod$coefficients[[1]]/1000+east_ind_north_mod$coefficients[[2]]/1000*latitude_mid]

east_ind_south_data <- data.table(latitude_mid = unique(east_ind_shelf_areas[latitude_end <0,]$latitude_mid))

east_ind_south_data[,area_1000s := east_ind_south_mod$coefficients[[1]]/1000+east_ind_south_mod$coefficients[[2]]/1000*latitude_mid]

#east indian
(area_latitude_east_ind  <- ggplot() +
#  geom_line(data = east_ind_north_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") + not significant
#  geom_line(data = east_ind_south_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") + not significant
  geom_point(data = east_ind_shelf_areas, aes(x=latitude_start, y=area_1000s), shape =18, size = 0.7) +
  geom_line(data = east_ind_shelf_areas, aes(x=latitude_start, y=area_1000s), size = 0.7) +
  geom_rug(data = east_ind_shelf_areas_highlight, aes(x = latitude_start, color = as.factor(change_above_2fold))) +
 labs(x=paste0("Latitude ","\u00B0","E"), y = expression(paste("Area (1000s of ", km^{2},")"))) +
  scale_color_viridis_d(option = "A", begin = 0.3, end = 0.7, name = "Associated Change\nin Shelf Area", labels = c("Contraction", "Expansion")) +
  ##annotate("text", x =22, y = 70000, label = "Eastern Indian Ocean") +
  geom_vline(xintercept = 0) +
  xlim(min(east_ind_shelf_areas$latitude_end), max(east_ind_shelf_areas$latitude_end)) +
  coord_flip() +
  theme_classic() +
  theme(plot.margin = margin(10, 40, 10, 10)))


  ggsave(area_latitude_east_ind, filename = "area_latitude_east_ind_2degrees.jpg", height = 4, units = c("in"))
  
##west indian
west_ind_north_data <- data.table(latitude_mid = unique(west_ind_shelf_areas[latitude_end>0,]$latitude_mid))

west_ind_north_data[,area_1000s := west_ind_north_mod$coefficients[[1]]/1000+west_ind_north_mod$coefficients[[2]]/1000*latitude_mid]

west_ind_south_data <- data.table(latitude_mid = unique(west_ind_shelf_areas[latitude_end <0,]$latitude_mid))

west_ind_south_data[,area_1000s := west_ind_south_mod$coefficients[[1]]/1000+west_ind_south_mod$coefficients[[2]]/1000*latitude_mid]

(area_latitude_west_ind  <- ggplot() +
  geom_line(data = west_ind_north_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
 # geom_line(data = west_ind_south_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") + not significant
  geom_point(data = west_ind_shelf_areas, aes(x=latitude_start, y=area_1000s), shape =18, size = 0.7) + 
  geom_line(data = west_ind_shelf_areas, aes(x=latitude_start, y=area_1000s), size = 0.7) +
    geom_rug(data = west_ind_shelf_areas_highlight, aes(x = latitude_start, color = as.factor(change_above_2fold))) +
 labs(x=paste0("Latitude ","\u00B0","E"), y = expression(paste("Area (1000s of ", km^{2},")"))) +
  scale_color_viridis_d(option = "A", begin = 0.3, end = 0.7, name = "Associated Change\nin Shelf Area", labels = c("Contraction", "Expansion")) +
  #annotate("text", x = 30, y = 33000, label = "Western Indian Ocean") +
  geom_vline(xintercept = 0) +
  xlim(min(west_ind_shelf_areas$latitude_end), max(west_ind_shelf_areas$latitude_end)) +
  coord_flip() +
  theme_classic() +
  theme(plot.margin = margin(10, 40, 10, 10)))

  ggsave(area_latitude_west_ind, filename = "area_latitude_west_ind_2degrees.jpg", height = 4, units = c("in"))

west_atl_north_data <- data.table(latitude_mid = unique(west_atl_shelf_areas[latitude_end>0,]$latitude_mid))

west_atl_north_data[,area_1000s := west_atl_north_mod$coefficients[[1]]/1000+west_atl_north_mod$coefficients[[2]]/1000*latitude_mid]

west_atl_south_data <- data.table(latitude_mid = unique(west_atl_shelf_areas[latitude_end <0,]$latitude_mid))

west_atl_south_data[,area_1000s := west_atl_south_mod$coefficients[[1]]/1000+west_atl_south_mod$coefficients[[2]]/1000*latitude_mid]

area_latitude_west_atl  <- ggplot() +
  geom_line(data = west_atl_north_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
  geom_line(data = west_atl_south_data, aes(x=-latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
  geom_point(data = west_atl_shelf_areas, aes(x=latitude_start, y=area_1000s), shape =18, size = 0.7) + 
  geom_line(data = west_atl_shelf_areas, aes(x=latitude_start, y=area_1000s), size = 0.7) +
  geom_rug(data = west_atl_shelf_areas_highlight, aes(x = latitude_start, color = as.factor(change_above_2fold))) +
 labs(x=paste0("Latitude ","\u00B0","E"), y = expression(paste("Area (1000s of ", km^{2},")"))) +
  scale_color_viridis_d(option = "A", begin = 0.3, end = 0.7, name = "Associated Change\nin Shelf Area", labels = c("Contraction", "Expansion")) +
  #annotate("text", x = 80, y = 120000, label = "Western Atlantic Ocean") +
  geom_vline(xintercept = 0) +
  xlim(min(west_atl_shelf_areas$latitude_end), max(west_atl_shelf_areas$latitude_end)) +
  coord_flip() +
  theme_classic() +
  theme(plot.margin = margin(10, 40, 10, 10))

  ggsave(area_latitude_west_atl, filename = "area_latitude_west_atl_2degrees.jpg", height = 4, units = c("in"))

  
east_atl_north_data <- data.table(latitude_mid = unique(east_atl_shelf_areas[latitude_end>0,]$latitude_mid))

east_atl_north_data[,area_1000s := east_atl_north_mod$coefficients[[1]]/1000+east_atl_north_mod$coefficients[[2]]/1000*latitude_mid]

east_atl_south_data <- data.table(latitude_mid = unique(east_atl_shelf_areas[latitude_end <0,]$latitude_mid))

east_atl_south_data[,area_1000s := east_atl_south_mod$coefficients[[1]]/1000+east_atl_south_mod$coefficients[[2]]/1000*latitude_mid]  

area_latitude_east_atl  <- ggplot() +
  geom_line(data = east_atl_north_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
  geom_line(data = east_atl_south_data, aes(x=-latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
  geom_point(data = east_atl_shelf_areas, aes(x=latitude_start, y=area_1000s), shape =18, size = 0.7) + 
  geom_line(data = east_atl_shelf_areas, aes(x=latitude_start, y=area_1000s), size = 0.7) +
  geom_rug(data = east_atl_shelf_areas_highlight, aes(x = latitude_start, color = as.factor(change_above_2fold))) +
 labs(x=paste0("Latitude ","\u00B0","E"), y = expression(paste("Area (1000s of ", km^{2},")"))) +
  scale_color_viridis_d(option = "A", begin = 0.3, end = 0.7, name = "Associated Change\nin Shelf Area", labels = c("Contraction", "Expansion")) +
  #annotate("text", x = 82.5, y = 110000, label = "Eastern Atlantic Ocean") +
  geom_vline(xintercept = 0) +
  xlim(min(east_atl_shelf_areas$latitude_end), max(east_atl_shelf_areas$latitude_end)) +
  coord_flip() +
  theme_classic() +
  theme(plot.margin = margin(10, 40, 10, 10))

  ggsave(area_latitude_east_atl, filename = "area_latitude_east_atl_2degrees.jpg", height = 4, units = c("in"))
  
  
east_pac_north_data <- data.table(latitude_mid = unique(east_pac_shelf_areas[latitude_end>0,]$latitude_mid))

east_pac_north_data[,area_1000s := east_pac_north_mod$coefficients[[1]]/1000+east_pac_north_mod$coefficients[[2]]/1000*latitude_mid]

east_pac_south_data <- data.table(latitude_mid = unique(east_pac_shelf_areas[latitude_end <0,]$latitude_mid))

east_pac_south_data[,area_1000s := east_pac_south_mod$coefficients[[1]]/1000+east_pac_south_mod$coefficients[[2]]/1000*latitude_mid]

area_latitude_east_pac  <- ggplot() +
  geom_line(data = east_pac_north_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
#  geom_line(data = east_pac_south_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") + not significant
  geom_point(data = east_pac_shelf_areas, aes(x=latitude_start, y=area_1000s), shape =18, size = 0.7) + 
  geom_line(data = east_pac_shelf_areas, aes(x=latitude_start, y=area_1000s), size = 0.7) +
  geom_rug(data = east_pac_shelf_areas_highlight, aes(x = latitude_start, color = as.factor(change_above_2fold))) +
 labs(x=paste0("Latitude ","\u00B0","E"), y = expression(paste("Area (1000s of ", km^{2},")"))) +
  scale_color_viridis_d(option = "A", begin = 0.3, end = 0.7, name = "Associated Change\nin Shelf Area", labels = c("Contraction", "Expansion")) +
  #annotate("text", x = 80, y = 130000, label = "Eastern Pacific Ocean") +
  geom_vline(xintercept = 0) +
  xlim(min(east_pac_shelf_areas$latitude_end), max(east_pac_shelf_areas$latitude_end)) +
  coord_flip() +
  theme_classic() +
  theme(plot.margin = margin(10, 40, 10, 10))

  ggsave(area_latitude_east_pac, filename = "area_latitude_east_pac_2degrees.jpg", height = 4, units = c("in"))

  
west_pac_north_data <- data.table(latitude_mid = unique(west_pac_shelf_areas[latitude_end>0,]$latitude_mid))

west_pac_north_data[,area_1000s := west_pac_north_mod$coefficients[[1]]/1000+west_pac_north_mod$coefficients[[2]]/1000*latitude_mid]

west_pac_south_data <- data.table(latitude_mid = unique(west_pac_shelf_areas[latitude_end <0,]$latitude_mid))

west_pac_south_data[,area_1000s := west_pac_south_mod$coefficients[[1]]/1000+west_pac_south_mod$coefficients[[2]]/1000*latitude_mid]

(area_latitude_west_pac <- ggplot() +
  geom_line(data = west_pac_north_data, aes(x=latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
    scale_color_manual(values = "gray60", labels = "Area ~ Latitude\nLinear Regression") +
  geom_line(data = west_pac_south_data, aes(x=-latitude_mid, y = area_1000s), color = "gray60", size = 0.8, linetype = "longdash") +
  geom_point(data = west_pac_shelf_areas, aes(x=latitude_start, y=area_1000s), shape =18, size = 0.7) + 
  geom_line(data = west_pac_shelf_areas, aes(x=latitude_start, y=area_1000s), size = 0.7) +
  geom_rug(data = west_pac_shelf_areas_highlight, aes(x = latitude_start, color = as.factor(change_above_2fold))) +
 labs(x=paste0("Latitude ","\u00B0","E"), y = expression(paste("Area (1000s of ", km^{2},")"))) +
  scale_color_viridis_d(option = "A", begin = 0.3, end = 0.7, name = "Associated Change\nin Shelf Area", labels = c("Contraction", "Expansion")) +
  #annotate("text", x = 90, y = 130000, label = "Western Pacific Ocean") +
  geom_vline(xintercept = 0) +
  xlim(min(west_pac_shelf_areas$latitude_end), max(west_pac_shelf_areas$latitude_end)) +
  coord_flip() +
  theme_classic() +
  theme(plot.margin = margin(10, 40, 10, 10)))

  

  ggsave(area_latitude_west_pac, filename = "area_latitude_west_pac_2degrees.jpg", height = 4, units = c("in"))
  
  #pull generic rug legend only
area_latitude_rug_legend <- get_legend(area_latitude_west_pac)
save(area_latitude_rug_legend, file = here::here("Figures", "Figure3_5", "area_latitude_rug_legend.RData"))

#save these in RData object
save(area_latitude_east_atl, area_latitude_east_ind, area_latitude_east_pac, area_latitude_west_atl, area_latitude_west_ind, area_latitude_west_pac, file = "latitude_area_plots.RData")

```
Dumby graph to just make additional legend component
```{r additional legend component}
legend_lat_area_regression <- get_legend(
  ggplot() +
  geom_line(data = west_pac_north_data, aes(x=latitude_mid, y = area_1000s, color = "value"), size = 0.8, linetype = "longdash") +
    scale_color_manual(values = "gray60", labels = "Area ~ Latitude\nLinear Regression") +
    coord_flip() +
  theme_classic() +
  theme(plot.margin = margin(10, 40, 10, 10), legend.title = element_blank()))

save(legend_lat_area_regression, file = here::here("Figures", "Figure3_5", "legend_lat_area_regression.RData"))
```

How many experience 'significant' changes in habitat (at least -50% or +100% change from one bin to another) I will go with IUCN 50% loss -> vulnerable species designation.

Bin shifts --> contractions (loss of 50%) versus expansions (gain of 200%) versus neutral
```{r bin shift categorization}

library(ggrepel)
#call all objects in environment with "stats" string
stats_string<-grep("areas_stats",names(.GlobalEnv),value=TRUE)
stats_string_list<-do.call("list",mget(stats_string))
names(stats_string_list) #check

#rownames
stats_string_rownames <- rep(names(stats_string_list), each = 3)
stats_string_type <- rep(c("contraction", "neutral", "expansion"),times = 6)

#check <- c("Eastern Indian Ocean" ,"Western Pacific Ocean" ,"Eastern Pacific Ocean" ,"Western Atlantic Ocean" ,"Western Indian Ocean" ,"Eastern Atlantic Ocean")

significant_changes <- as.data.table(rbind(stats_string_list[[1]],stats_string_list[[2]],stats_string_list[[3]],stats_string_list[[4]],stats_string_list[[5]],stats_string_list[[6]]))

significant_changes[, region := stats_string_rownames][,type := stats_string_type]

#melt to plot
significant_changes.long <- melt(significant_changes, id.vars = c("region","type"), variable.name = "hemisphere", measure.vars = c("north", "south"))

#calculate percentages
significant_changes.long[,total_bins_hemisphere := sum(value),.(region, hemisphere)][,total_bins_region := sum(value),region][,percent_by_hemisphere := round(sum(value)/total_bins_hemisphere*100,2),.(region,hemisphere,type)][,percent_by_region := round(sum(value)/total_bins_region*100,2), .(region,type)]

significant_changes.long[,type := factor(type, levels = c("contraction","neutral","expansion"))][,region_names := factor(region, levels = c("east_atl_shelf_areas_stats", "west_atl_shelf_areas_stats", "east_ind_shelf_areas_stats", "west_ind_shelf_areas_stats" ,"east_pac_shelf_areas_stats" ,"west_pac_shelf_areas_stats"), labels = c("East Atlantic", "West Atlantic", "East Indian", "West Indian" ,"East Pacific" ,"West Pacific"))][,hemisphere := factor(hemisphere,levels = c("north","south"), labels = c("North","South"))]




blank_theme <- theme_minimal()+
  theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.border = element_blank(),
  panel.grid=element_blank(),
  axis.ticks = element_blank(),
  plot.title=element_text(size=14, face="bold")
  )

#viridis magma palette, Contractions [1], expansions[2])
viridis_exp_cont <-viridis_pal(begin = 0.3, end = 0.7, option = "A")(2)

#by hemisphere

ggplot(data = significant_changes.long, aes(x="", y = percent_by_hemisphere, fill = type)) +
  geom_bar(stat = "identity", width = 1, alpha = 0.8) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = c(viridis_exp_cont[1], "grey94", viridis_exp_cont[2]), name = "Shelf Area Change", labels = c("Contraction", "Neither", "Expansion")) +
  facet_grid(hemisphere~region_names) +
  geom_text_repel(aes(label = paste0(round(percent_by_hemisphere,1),"%")), size = 1, fontface = "bold", position = position_stack(vjust = 0.3)) +
  scale_x_discrete(expand = c(0,0)) +
  blank_theme +
  theme(axis.text.x=element_blank(),
        strip.text = element_text(size = 7),
        legend.title = element_text(size = 9), 
        legend.text = element_text(size = 7)) +
  guides(shape = guide_legend(override.aes = list(size = 0.5)), 
         fill = guide_legend(override.aes = list(size = 0.5)))

ggsave(filename = "figure6_habitatloss_gain_2fold_byhemisphere.jpg", height = 2, width = 6, unit = "in")
ggsave(filename = "figure6_habitatloss_gain_2fold_byhemisphere.eps", height = 2, width = 6, unit = "in")


#by region (hemisphere's compressed)
ggplot(data = unique(significant_changes.long[,.(region_names,type,percent_by_region)]), aes(x="", y = percent_by_region, fill = type)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = c(viridis_exp_cont[1], "grey94", viridis_exp_cont[2]), name = "Shelf Area Change", labels = c("Contraction", "Neither", "Expansion")) +
  facet_wrap(~region_names) +
  geom_text(aes(label = paste0(percent_by_region,"%")), position = position_stack(vjust = 0.1), size = 2) +
  scale_x_discrete(expand = c(0,0)) +
  blank_theme +
  theme(axis.text.x=element_blank())

ggsave(filename = "figure6_habitatloss_gain_2fold_byregion.jpg", height = 4, width = 8, unit = "in")
ggsave(filename = "figure6_habitatloss_gain_2fold_byregion.eps", height = 4, width = 8, unit = "in")


```

Now, I should make maps for each of these regions

Used https://gist.github.com/valentinitnelav/c7598fcfc8e53658f66feea9d3bafb40 for instructions

```{r setup world maps}
library(ggspatial)

  world <- ne_countries(scale = "medium", returnclass = "sf")

# ~~~~~~~~~~~ Download shapefile from www.naturalearthdata.com ~~~~~~~~~~~ #
# Download countries data
#download.file(url = "http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/cultural/ne_110m_admin_0_countries.zip", 
#              destfile = "ne_110m_admin_0_countries.zip")
# unzip the shapefile in the directory mentioned with "exdir" argument
#unzip(zipfile="ne_110m_admin_0_countries.zip", exdir = "ne_110m_admin_0_countries")
# delete the zip file
#file.remove("ne_110m_admin_0_countries.zip")
# read the shapefile with readOGR from rgdal package
NE_countries <- readOGR(dsn = "ne_110m_admin_0_countries", layer = "ne_110m_admin_0_countries")
class(NE_countries) # is a SpatialPolygonsDataFrame object

# ~~~~~~~~~~~ Split world map by "split line" ~~~~~~~~~~~ #

# shift central/prime meridian towards west – positive values only
shift <- 180 +30

# create "split line" to split country polygons
WGS84 <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
split.line <- SpatialLines(list(Lines(list(Line(cbind(180-shift,c(-90,90)))), ID="line")), 
                          proj4string=WGS84)

# NOTE - in case of TopologyException' errors when intersecting line with country polygons,
# apply the gBuffer solution suggested at:
# http://gis.stackexchange.com/questions/163445/r-solution-for-topologyexception-input-geom-1-is-invalid-self-intersection-er
NE_countries <- gBuffer(NE_countries, byid=TRUE, width=0)

# intersecting line with country polygons
line.gInt <- gIntersection(split.line, NE_countries)

# create a very thin polygon (buffer) out of the intersecting "split line"
bf <- gBuffer(line.gInt, byid=TRUE, width=0.000001)  

# split country polygons using intersecting thin polygon (buffer)
NE_countries.split <- gDifference(NE_countries, bf, byid=TRUE)
# plot(NE_countries.split) # check map
class(NE_countries.split) # is a SpatialPolygons object

# ~~~~~~~~~~~ Create graticules ~~~~~~~~~~~ #
# create a bounding box - world extent
b.box <- as(raster::extent(-180, 180, -90, 90), "SpatialPolygons")
# assign CRS to box
proj4string(b.box) <- WGS84
# create graticules/grid lines from box
grid <- gridlines(b.box, 
                  easts  = seq(from=-180, to=180, by=20),
                  norths = seq(from=-90, to=90, by=10))

# create labels for graticules
grid.lbl <- labels(grid, side = 1:4)

# transform labels from SpatialPointsDataFrame to a data table that ggplot can use
grid.lbl.DT <- data.table(grid.lbl@coords, grid.lbl@data)

# prepare labels with regular expression:
# - delete unwanted labels
grid.lbl.DT[, labels := gsub(pattern="180\\*degree|90\\*degree\\*N|90\\*degree\\*S", replacement="", x=labels)]
# - replace pattern "*degree" with "°" (* needs to be escaped with \\)
grid.lbl.DT[, lbl := gsub(pattern="\\*degree", replacement="°", x=labels)]
# - delete any remaining "*"
grid.lbl.DT[, lbl := gsub(pattern="*\\*", replacement="", x=lbl)]

# adjust coordinates of labels so that they fit inside the globe
grid.lbl.DT[, long := ifelse(coords.x1 %in% c(-180,180), coords.x1*175/180, coords.x1)]
grid.lbl.DT[, lat  := ifelse(coords.x2 %in% c(-90,90), coords.x2*82/90, coords.x2)]

# ~~~~~~~~~~~ Prepare data for ggplot, shift & project coordinates ~~~~~~~~~~~ #
# give the PORJ.4 string for Eckert IV projection ( changed to different projection, "+proj=eck4 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs" for eckert)
PROJ <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0" 

# transform graticules from SpatialLines to a data table that ggplot can use
grid.DT <- data.table(map_data(SpatialLinesDataFrame(sl=grid, 
                                                     data=data.frame(1:length(grid)), 
                                                     match.ID = FALSE)))
# project coordinates
# assign matrix of projected coordinates as two columns in data table
grid.DT[, c("X","Y") := data.table(project(cbind(long, lat), proj=PROJ))]

# project coordinates of labels
grid.lbl.DT[, c("X","Y") := data.table(project(cbind(long, lat), proj=PROJ))]

# transform split country polygons in a data table that ggplot can use
Country.DT_shift <- data.table(map_data(as(NE_countries.split, "SpatialPolygonsDataFrame")))
Country.DT <- data.table(map_data(as(NE_countries, "SpatialPolygonsDataFrame")))
# Shift coordinates
Country.DT_shift[, long.new := long + shift]
Country.DT_shift[, long.new := ifelse(long.new > 180, long.new-360, long.new)]

# project coordinates 
Country.DT[, c("X","Y") := data.table(project(cbind(long, lat), proj=PROJ))]
Country.DT_shift[, c("X","Y") := data.table(project(cbind(long.new, lat), proj=PROJ))]

# ~~~~~~~~~~~ Plot map ~~~~~~~~~~~ #
ggplot() + 
    # add projected countries
    geom_polygon(data = Country.DT_shift, 
                 aes(x = long.new+150, y = lat, group = group), 
                 colour = "gray70", 
                 fill = "gray90", 
                 size = 0.25) +
    # add graticules
    geom_path(data = grid.DT, 
              aes(x = X, y = Y, group = group), 
              linetype = "dotted", colour = "grey50", size = .25) +
    # add a bounding box (select graticules at edges)
    geom_path(data = grid.DT[(long %in% c(-180,180) & region == "NS")
                             |(long %in% c(-180,180) & lat %in% c(-90,90) & region == "EW")], 
              aes(x = X, y = Y, group = group), 
              linetype = "solid", colour = "black", size = .3) +
    # add graticule labels
    geom_text(data = grid.lbl.DT, # latitude
              aes(x = X, y = Y, label = lbl), 
              colour = "grey50", size = 2) +
    # ensures that one unit on the x-axis is the same length as one unit on the y-axis
    coord_equal() + # same as coord_fixed(ratio = 1)
    # set empty theme
    theme_void()

```

```{r mapping each region}

region_maps <- list()
regions_shift_projection <- c("west_pac_spdf_shift", "east_pac_spdf_shift")


#change names to match new merged regions with non-LMEs (mask_full)
east_pac_spdf_shift_mask_full <- east_pac_spdf_shift_mask_1s
west_atl_spdf_mask_full <- west_atl_spdf_mask_1s
west_ind_spdf_mask_full <- west_ind_spdf_mask_1s
east_atl_spdf_nobuf_mask_full <- east_atl_spdf_nobuf_mask_1s
west_pac_spdf_shift_mask_full <- west_pac_spdf_mask_full
east_ind_spdf_mask_full <- east_ind_spdf_mask_1s




for (i in 1:length(region_names)) {
  
  region_spdf <- get(paste0(region_names[i], "_mask"))
  
  if(region_names[i] %in% regions_shift_projection) {
  
  #pacific centered projection
  
  region_spdf_mask_1s_extent <- extent(get(paste0(region_names[i],"_mask_full"))) # take extent of region
  
  #convert rasters to dfs data frame
  region_spdf <- as(get(paste0(region_names[i],"_mask_full")), "SpatialPixelsDataFrame")
  region_df <- as.data.frame(region_spdf)
  colnames(region_df) <- c("value", "x", "y")
  
  
  (region_maps[[i]] <- ggplot() + 
    # add projected countries
    geom_polygon(data = Country.DT_shift, 
                 aes(x = long.new+150, y = lat, group = group), 
                 colour = "gray70", 
                 fill = "gray90", 
                 size = 0.25) +
    geom_tile(data = region_df, aes(x = x, y = y, fill = value, color = "lightsteelblue4"), color = "lightsteelblue4") +
    coord_sf(x=c((min(region_df$x)),(max(region_df$x))),y=c((min(region_df$y)),(max(region_df$y)))) +
    labs( x = paste0("Longitude ", "\u00B0E"), y = paste0("Latitude ", "\u00B0N")) +
    geom_abline(intercept = 0, slope = 0) +
    theme_classic() +
    theme(legend.position = "none"))
  
  filename <- paste0(region_names[i], "_map_2degrees.jpg")
  ggsave(plot = region_maps[[i]], filename = filename, height = 4, units = c("in"))
  
  } else {

  #atlantic centered projection
  region_spdf_mask_1s_extent <- extent(get(paste0(region_names[i],"_mask_full"))) # take extent of region
  
  #convert rasters to dfs data frame
  region_spdf <- as(get(paste0(region_names[i],"_mask_full")), "SpatialPixelsDataFrame")
  region_df <- as.data.frame(region_spdf)
  colnames(region_df) <- c("value", "x", "y")
  
  
  (region_maps[[i]] <- ggplot() + 
    # add projected countries
    geom_polygon(data = Country.DT, 
                 aes(x = long, y = lat, group = group), 
                 colour = "gray70", 
                 fill = "gray90", 
                 size = 0.25) +
    geom_tile(data = region_df, aes(x = x, y = y, fill = as.factor(value))) +
      scale_fill_manual(values = "lightsteelblue4", labels = "Continental Shelf Area") +
    coord_sf(x = c(region_spdf_mask_1s_extent[1], region_spdf_mask_1s_extent[2]), y = c(region_spdf_mask_1s_extent[3], region_spdf_mask_1s_extent[4])) +
    labs( x = paste0("Longitude ", "\u00B0E"), y = paste0("Latitude ", "\u00B0N")) +
    geom_abline(intercept = 0, slope = 0) +
    theme_classic() +
      theme(legend.title = element_blank()))
  
  filename <- paste0(region_names[i], "_map_2degrees.jpg")
  ggsave(plot = region_maps[[i]], filename = filename, height = 4, units = c("in"))
  
  }
  
}

region_map_legend <- get_legend(region_maps[[6]])

#save maps
save(region_maps, file = here::here("Figures","Figure3_5", "region_maps.RData"))
#save map legend
save(region_map_legend, file = here::here("Figures","Figure3_5", "region_maps_legend.RData"))

#save all area versus latitude plots 
save(area_latitude_east_pac , area_latitude_west_pac , area_latitude_east_atl , area_latitude_west_atl , area_latitude_east_ind , area_latitude_west_ind, file = here::here("Figures","Figure3_5", "latitude_2degree_maps.RData"))
```

Combining plots

region_maps: 
"west_pac_spdf_shift", 
"east_pac_spdf_shift", 
"west_atl_spdf", 
"west_ind_spdf", 
"east_atl_spdf_nobuf", 
"east_ind_spdf"

Plots of area versus latitude
area_latitude_east_pac
area_latitude_west_pac
area_latitude_east_atl
area_latitude_west_atl
area_latitude_east_ind
area_latitude_west_ind

Now, combine plots

NB: these are still not quite aligning axis correctly, I'll play with it later

```{r combining plots}
library(egg)
library(ggpubr)

#west pacific
(west_pacific_merge_map_plot <- egg::ggarrange(region_maps[[1]] + ylim(y=c(min(west_pac_shelf_areas$latitude_start),max(west_pac_shelf_areas$latitude_start))), 
          area_latitude_west_pac 
          + 
               theme(axis.text.y = element_blank(),
               #      axis.ticks.y = element_blank(),
                     axis.title.y = element_blank() ) +
            xlim(x=c(min(west_pac_shelf_areas$latitude_start),max(west_pac_shelf_areas$latitude_start))) +
                                                 scale_x_continuous(breaks = c(-40,-20,0,20,40,60,80)), 

          nrow = 1,
          top = T,
          widths = c(2,1)))

ggsave(plot = west_pacific_merge_map_plot, filename = "west_pacific_merge_map_plot_2degrees.jpg", width = 7, height = 3, units = "in")

#east pacific
(east_pacific_merge_map_plot <- egg::ggarrange(region_maps[[2]] + ylim(y=c(min(east_pac_shelf_areas$latitude_start),max(east_pac_shelf_areas$latitude_start))), 
          area_latitude_east_pac 
          + 
               theme(axis.text.y = element_blank(),
               #      axis.ticks.y = element_blank(),
                     axis.title.y = element_blank() ) +
            xlim(x=c(min(east_pac_shelf_areas$latitude_start),max(east_pac_shelf_areas$latitude_start))) +
                                                 scale_x_continuous(breaks = c(-60,-40,-20,0,20,40,60,80)), 

          nrow = 1,
          top = T, bottom = T
          , 
          widths = c(2,1)
  ))

ggsave(plot = east_pacific_merge_map_plot, filename = "east_pacific_merge_map_plot_2degrees.jpg", width = 7, height = 3, units = "in")

#both together (will do later, not worth it now)
library(cowplot)
figure_3_pacific_merge_top <- egg::ggarrange(region_maps[[1]] + theme(axis.title.x = element_blank(), plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          area_latitude_west_pac + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.title.x = element_blank(),
                     legend.position = "none",
                     plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          nrow = 1, ncol = 2, top = T, bottom = T, widths = c(1.5,1))

figure_3_pacific_merge_bottom <- egg::ggarrange(region_maps[[2]] + theme(plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          area_latitude_east_pac + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     legend.position = "none",
                     plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          nrow = 1, ncol = 2, top = T, bottom = T, widths = c(1.5,1))

legend <- get_legend(area_latitude_east_pac)

figure_3_pacific_merge <- plot_grid(figure_3_pacific_merge_top, figure_3_pacific_merge_bottom, ncol = 1, nrow = 2, labels = c("a.","b.")
                                    #, axis = "l", align = "v", hjust = -7, rel_heights = c(1,1.5)
                                    )

figure_3_pacific_merge_legend <- plot_grid(figure_3_pacific_merge, legend, ncol = 2, nrow = 1, rel_widths = c(4,1))

ggsave(figure_3_pacific_merge_legend, path = here::here("Figures", "Figure3_5"), filename = "Figure3_Pacific_latitude_area.jpg", height = 4, width = 6, unit = "in")

```


```{r atlantic ocean}
#east atlantic
(east_atlantic_merge_map_plot <- egg::ggarrange(region_maps[[5]] + theme(legend.position = "none"), 
          area_latitude_east_atl
          + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank())
          , 

          nrow = 1,
          top = T,
          widths = c(2,1)))

ggsave(plot = east_atlantic_merge_map_plot, filename = "east_atlantic_merge_map_plot_2degrees.jpg", width = 7, height = 3, units = "in")

#west atlantic
(west_atlantic_merge_map_plot <- egg::ggarrange(region_maps[[3]] + theme(legend.position = "none"), 
          area_latitude_west_atl
          + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     legend.position = "none" )
          , 

          nrow = 1,
          top = T, 
          widths = c(2,1)))

ggsave(plot = west_atlantic_merge_map_plot, filename = "west_atlantic_merge_map_plot_2degrees.jpg", width = 7, height = 3, units = "in")

#both together
library(cowplot)
figure_4_atlantic_merge_top <- egg::ggarrange(region_maps[[3]] + theme(axis.title.x = element_blank(), plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          area_latitude_west_atl + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.title.x = element_blank(),
                     legend.position = "none",
                     plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          nrow = 1, ncol = 2, top = T, bottom = T, widths = c(1.5,1))

figure_4_atlantic_merge_bottom <- egg::ggarrange(region_maps[[5]] + theme(plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          area_latitude_east_atl + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     legend.position = "none",
                     plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          nrow = 1, ncol = 2, top = T, bottom = T, widths = c(1.5,1))

legend <- get_legend(area_latitude_east_atl)

figure_4_atlantic_merge <- plot_grid(figure_4_atlantic_merge_top, figure_4_atlantic_merge_bottom, ncol = 1, nrow = 2, labels = c("a.","b."), axis = "l", align = "v", hjust = -7, rel_heights = c(1.1,1))

figure_4_atlantic_merge_legend <- plot_grid(figure_4_atlantic_merge, legend, ncol = 2, nrow = 1, rel_widths = c(4,1))

ggsave(figure_4_atlantic_merge_legend, path = here::here("Figures", "Figure3_5"), filename = "Figure4_atlantic_latitude_area.jpg", height = 4, width = 6, unit = "in")
```

```{r indian ocean}
#west indian
(west_indian_merge_map_plot <- egg::ggarrange(region_maps[[4]] + ylim(y=c(min(west_ind_shelf_areas$latitude_start),max(west_ind_shelf_areas$latitude_start))) + theme(legend.position = "none"), 
          area_latitude_west_ind 
          + 
               theme(axis.text.y = element_blank(),
               #      axis.ticks.y = element_blank(),
                     axis.title.y = element_blank() ) +
            xlim(x=c(min(west_ind_shelf_areas$latitude_start),max(west_ind_shelf_areas$latitude_start))) +
                                                 scale_x_continuous(breaks = c(-40,-30,-20,-10,0,10,20,30)), 

          nrow = 1,
          top = T,
          widths = c(2,1)))

ggsave(plot = west_indian_merge_map_plot, filename = "west_indian_merge_map_plot_2degrees.jpg", width = 7, height = 3, units = "in")

#east indian
(east_indian_merge_map_plot <- egg::ggarrange(region_maps[[6]] + ylim(y=c(min(east_ind_shelf_areas$latitude_start),max(east_ind_shelf_areas$latitude_start))) + theme(legend.position = "none"), 
          area_latitude_east_ind 
          + 
               theme(axis.text.y = element_blank(),
               #      axis.ticks.y = element_blank(),
                     axis.title.y = element_blank() ) +
            xlim(x=c(min(east_ind_shelf_areas$latitude_start),max(east_ind_shelf_areas$latitude_start))) +
                                                 scale_x_continuous(breaks = c(-60,-40,-20,0,20)), 

          nrow = 1,
          top = T, bottom = T
          , 
          widths = c(2,1)
  ))

ggsave(plot = east_indian_merge_map_plot, filename = "east_indian_merge_map_plot_2degrees.jpg", width = 7, height = 3, units = "in")

#both together
library(cowplot)
figure_5_indian_merge_top <- egg::ggarrange(region_maps[[4]] + theme(axis.title.x = element_blank(), plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          area_latitude_west_ind + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     axis.title.x = element_blank(),
                     legend.position = "none",
                     plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          nrow = 1, ncol = 2, top = T, bottom = T, widths = c(1.5,1))

figure_5_indian_merge_bottom <- egg::ggarrange(region_maps[[6]] + theme(plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          area_latitude_east_ind + 
               theme(axis.text.y = element_blank(),
                     axis.ticks.y = element_blank(),
                     axis.title.y = element_blank(),
                     legend.position = "none",
                     plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm")),
          nrow = 1, ncol = 2, top = T, bottom = T, widths = c(1.5,1))

legend <- get_legend(area_latitude_east_ind)

figure_5_indian_merge <- plot_grid(figure_5_indian_merge_top, figure_5_indian_merge_bottom, ncol = 1, nrow = 2, labels = c("a.","b."), axis = "l", align = "v", hjust = -7, rel_heights = c(1,1.2))

figure_5_indian_merge_legend <- plot_grid(figure_5_indian_merge, legend, ncol = 2, nrow = 1, rel_widths = c(4,1))

ggsave(figure_5_indian_merge_legend, path = here::here("Figures", "Figure3_5"), filename = "Figure5_indian_latitude_area.jpg", height = 4, width = 6, unit = "in")
```
And now final merge for figures 3-5
```{r final merge figures}
indian_latitude_2_plots <- ggarrange(west_indian_merge_map_plot, east_indian_merge_map_plot, nrow = 2, ncol = 1)
ggsave(indian_latitude_2_plots, file = "indian_latitude_2_plots.jpg", height = 6, unit = "in")
ggsave(indian_latitude_2_plots, file = "indian_latitude_2_plots.pdf", height = 6, unit = "in")

pacific_latitude_2_plots <- ggarrange(west_pacific_merge_map_plot, east_pacific_merge_map_plot, nrow = 2, ncol = 1)
ggsave(pacific_latitude_2_plots, file = "pacific_latitude_2_plots.jpg", height = 6, unit = "in")
ggsave(pacific_latitude_2_plots, file = "pacific_latitude_2_plots.pdf", height = 6, unit = "in")

atlantic_latitude_2_plots <- ggarrange(west_atlantic_merge_map_plot, east_atlantic_merge_map_plot, nrow = 2, ncol = 1)
ggsave(atlantic_latitude_2_plots, file = "atlantic_latitude_2_plots.jpg", height = 6, unit = "in")
ggsave(atlantic_latitude_2_plots, file = "atlantic_latitude_2_plots.pdf", height = 6, unit = "in")
```


Summary Table of Shifts away from Equator


```{r statistics table}
regional_statistics <- data.table()
regional_statistics[,region := rep(c("West Pacific", "East Pacific", "West Atlantic", "West Indian", "East Atlantic", "East Indian"),each = 2)][,hemisphere := rep(c("Northern", "Southern"),6)][,contractions := as.numeric(NA)][,expansions := as.numeric(NA)][,coef := as.numeric(NA)][,pvalue := as.numeric(NA)]

shelf_areas <- c("west_pac_shelf_areas", "east_pac_shelf_areas", "west_atl_shelf_areas", "west_ind_shelf_areas", "east_atl_shelf_areas", "east_ind_shelf_areas")

north_mods <- c("west_pac_north_mod", "east_pac_north_mod", "west_atl_north_mod", "west_ind_north_mod", "east_atl_north_mod", "east_ind_north_mod")

south_mods <- c("west_pac_south_mod", "east_pac_south_mod", "west_atl_south_mod", "west_ind_south_mod", "east_atl_south_mod", "east_ind_south_mod")

for (i in 1:length(shelf_areas)) {

  this_shelf_area <- get(shelf_areas[i])
    #populate west pacific
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Northern", "contractions"] <- round(this_shelf_area[latitude_end > 0 & change_above_2fold == -1,.N]/nrow(this_shelf_area[latitude_end > 0 & !is.na(percent_change)]),4)*100 #northern hemisphere contraction
    
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Southern", "contractions"] <- round(this_shelf_area[latitude_end < 0 & change_above_2fold == -1,.N]/nrow(this_shelf_area[latitude_end < 0 & !is.na(percent_change)]),4)*100 #southern hemisphere contraction
    
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Northern", "expansions"] <- round(this_shelf_area[latitude_end > 0 & change_above_2fold == 1,.N]/nrow(this_shelf_area[latitude_end > 0 & !is.na(percent_change)]),4)*100 #northern hemisphere expansion
    
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Southern", "expansions"] <- round(this_shelf_area[latitude_end < 0 & change_above_2fold == 1,.N]/nrow(this_shelf_area[latitude_end < 0 & !is.na(percent_change)]),4)*100 #southern hemisphere expansion
    
    #northern mod
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Northern", "coef"] <- round(get(north_mods[i])$coefficients[2],2)
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Northern", "pvalue"] <- round(summary(get(north_mods[i]))$coefficients[,"Pr(>|t|)"][2],2)
    
    #southern mod
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Southern", "coef"] <- round(get(south_mods[i])$coefficients[2],2)
    regional_statistics[region == unique(regional_statistics[,region])[i] & hemisphere == "Southern", "pvalue"] <- round(summary(get(south_mods[i]))$coefficients[,"Pr(>|t|)"][2],2)

}

view(regional_statistics)

#save
fwrite(regional_statistics, file = "Table1_regional_stats.csv")
```


```{r}

save(significant_changes.long, significant_changes, file = "significant_changes_2degrees.Rdata")

```
