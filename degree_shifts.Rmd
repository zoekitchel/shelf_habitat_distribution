---
title: "Degree shifts"
output: html_notebook
---

Degree shifts

Second part of paper, if we move away from equator by 1 degree, how much habitat do we gain or lost

I need to look at shelf area by degrees latitude

```{r setup}
library(raster)
library(sf)
library(ncdf4)
library(rmapshaper)
library(tidyverse)
library(diptest)
library(moments)
library(viridis) #colors
library(data.table)
library(hydroTSM) #hypsometric curves
library(gridExtra)
library(maptools)
library(rgdal)
library(rgeos)
library(SpaDES)
library(rnaturalearth)
library(rnaturalearthdata)


etopo_shelf_df <- readRDS("~/Documents/grad school/Rutgers/Repositories/shelf_habitat_distribution/etopo_shelf_df.rds")
#bring in bathymetry data frame for shelf regions

#LMEs
LME_spdf <- readOGR("LME66/LMEs66.shp") #spatial points data frame with all 66 LMEs
head(LME_spdf)

#function to go from coordinates to minutes symbols in plots
scale_x_longitude <- function(xmin=-180, xmax=180, step=0.002, ...) {
  xbreaks <- seq(xmin,xmax,step)
  xlabels <- unlist(
    lapply(xbreaks, function(x){
      ifelse(x < 0, parse(text=paste0(paste0(abs(dms(x)$d), expression("*{degree}*")),
                                      paste0(abs(dms(x)$m), expression("*{minute}*")),
                                      paste0(abs(dms(x)$s)), expression("*{second}*W"))), 
             ifelse(x > 0, parse(text=paste0(paste0(abs(dms(x)$d), expression("*{degree}*")),
                                             paste0(abs(dms(x)$m), expression("*{minute}*")),
                                             paste0(abs(dms(x)$s)), expression("*{second}*E"))),
                    abs(dms(x))))}))
  return(scale_x_continuous("Longitude", breaks = xbreaks, labels = xlabels, expand = c(0, 0), ...))
}

scale_y_latitude <- function(ymin=-90, ymax=90, step=0.002, ...) {
  ybreaks <- seq(ymin,ymax,step)
  ylabels <- unlist(
    lapply(ybreaks, function(x){
      ifelse(x < 0, parse(text=paste0(paste0(abs(dms(x)$d), expression("*{degree}*")),
                                      paste0(abs(dms(x)$m), expression("*{minute}*")),
                                      paste0(abs(dms(x)$s)), expression("*{second}*S"))), 
             ifelse(x > 0, parse(text=paste0(paste0(abs(dms(x)$d), expression("*{degree}*")),
                                             paste0(abs(dms(x)$m), expression("*{minute}*")),
                                             paste0(abs(dms(x)$s)), expression("*{second}*N"))),
                    abs(dms(x))))}))
  return(scale_y_continuous("Latitude", breaks = ybreaks, labels = ylabels, expand = c(0, 0), ...))
} 
```

Make bathymetry data frame into raster (this takes a bit)
```{r bathy to raster}
proj <- crs(LME_spdf)
etopo_shelf_raster <- rasterFromXYZ(etopo_shelf_df, crs = proj)

```

Crop bathymetry raster to LME spdf (not sure if this is necessary, may just be able to use etopo shelf raster)
```{r}

#crop bathy layer to LME subset
LMEs_extent <- crop(etopo_shelf_raster, extent(LME_spdf))


```

Should go by projections of where species are moving:
"Marine species (~80% being ectotherms in the database; Extended Data Fig. 2) have moved towards the poles at a mean (±s.e.m.) pace of 5.92 ± 0.94 km yr−1 (one-sample Student’s t-test: t=6.26; d.f. residuals=23; P=2.20×10–6), which is almost six times faster than terrestrial species (one-way analysis of variance (ANOVA): F=12.68; d.f. factor=1; d.f. residuals=45; P=8.88×10–4)." Lenoir 2020

5.92 km * 10 = 59.2 km in 10 years

59.2 km is how many degrees?

1° = 111 km

so, 

```{r quick conversion}
59.2/111*1

```

0.5333˚ is representative of decadal shifts

I will put areas into 0.5˚ Bins (180 total degrees, so 180/0.5=360)

```{r}
180/0.5
```

How does continental shelf habitat change with latitude?

Plot Latitude by Area

Northern Hemisphere

```{r use data table to get bins}
etopo_shelf_dt <- as.data.table(etopo_shelf_df) #bathymetry into data table
etopo_shelf_dt_north <- etopo_shelf_dt[y >= 0,][,habitat := ifelse(is.na(layer), 0,1)] #if in northern hemisphere
setorder(etopo_shelf_dt_north, y)
etopo_shelf_dt_south <- etopo_shelf_dt[y <= 0,][,habitat := ifelse(is.na(layer), 0,1)] #if in southern hemisphere
setorder(etopo_shelf_dt_south, -y)
```

Binning data by 0.5 ˚
```{r}
etopo_shelf_dt_north_binned <- etopo_shelf_dt_north[,sum(habitat) , .(gr=cut(y,breaks=seq(0,90,by = (0.5))))]
etopo_shelf_dt_south_binned <- etopo_shelf_dt_south[,sum(habitat) , .(gr=cut(y,breaks=seq(0,-90,by = (-0.5))))]
```

Keep above because it's interesting global perspective (how does total shelf area vary by latitude?)

However, makes more sense to look at by contiguous coast lines AND we don't actually need depth info TBH!

Eastern Atlantic (3)
-19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 58, 59, 60, 62

Western Atlantic (2)
- 5, 6, 7, 8, 9, 12, 14, 15, 16, 17, 18, 61, 63, 66

Eastern Pacific (1)
- 1, 2, 3, 4, 11, 13, 54, 55, 61, 65

Western Indian (4)
-30, 31, 32, 33

Eastern Indian (5)
-34, 38, 43, 44, 45

Western Pacific (6)
1,	35,	36,	37,	39,	40,	41,	42,	46,	47,	48,	49,	50,	51,	52,	53,	54,	56,	57,	65

Using Hailey's file which seems to line up

Merge LMEs into 6 LMEs

- keep in mind, LME 1 (1&6) and 54 (1&6) and 61 (1&2) and 65 (1&6) appear in multiple
```{r }
west_pac <- c(1,	35,	36,	37,	39,	40,	41,	42,	46,	47,	48,	49,	50,	51,	52,	53,	54,	56,	57,	65)
east_pac <- c(1, 2, 3, 4, 11, 13, 54, 55, 61, 65)
west_atl <- c(5, 6, 7, 8, 9, 12, 14, 15, 16, 17, 18, 61, 63, 66)
east_atl <- c(19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 58, 59, 60, 62)
west_ind <- c(30, 31, 32, 33)
east_ind <- c(34, 38, 43, 44, 45)

#subregions based on LME_number
west_pac_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% west_pac,]
east_pac_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% east_pac,]
west_atl_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% west_atl,]
west_ind_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% west_ind,]
east_atl_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% east_atl,]
east_ind_spdf <- LME_spdf[(LME_spdf$LME_NUMBER) %in% east_ind,]

#for subregions that span 360, we need to change CRS a bit
newCRS_west <- "+proj=longlat +datum=WGS84 +lon_wrap=180"
west_pac_spdf_shift <- spTransform(west_pac_spdf, CRS(newCRS_west))
west_pac_spdf_shift <- gBuffer(west_pac_spdf_shift, byid=TRUE, width=0) #gets rid of buffers, allows for union

newCRS_east <- "+proj=longlat +datum=WGS84 +lon_wrap=180"
east_pac_spdf_shift <- spTransform(east_pac_spdf, CRS(newCRS_east))
east_pac_spdf_shift <- gBuffer(east_pac_spdf_shift, byid=TRUE, width=0) #gets rid of buffers, allows for union
#rotate raster for bathymetry (guided by extent of etoposhelf raster,  that's why wacky #s)
x1 <- crop(etopo_shelf_raster, extent(-180.0167, -0.0167, -90.01667, 90.01667))
x2 <- crop(etopo_shelf_raster, extent(0, 180.0167, -90.01667, 90.01667))   
extent(x1) <- c(180.0167, 360.0167, -90.01667 , 90.01667)
etopo_shelf_raster_180 <- merge(x1, x2)

#get rid of buffer for east atl as well

east_atl_spdf_nobuf <- gBuffer(east_atl_spdf, byid=TRUE, width=0)

region_names <- c("west_pac_spdf_shift", "east_pac_spdf_shift", "west_atl_spdf", "west_ind_spdf", "east_atl_spdf_nobuf", "east_ind_spdf")



#dissolve all polygons by region
for (i in 1:length(region_names)) {
  name <- paste0(region_names[i], "_agg")
  assign(name, gUnaryUnion(get(region_names[i]))) #dissolve polygons into one
}

```


Extract bathymetry data from polygon only to make sure we're limiting to shelf regions above 2000 meters

```{r polygon to raster}

region_names_shift <- region_names[1:2]


region_names_noshift <- region_names[3:6]


for (i in 1:length(region_names_noshift)) {
#crop bathymetry layer to LME subset (continental shelf habitat in LMEs)
  raster_extent <-
       crop(etopo_shelf_raster, extent(get(paste0(region_names_noshift[i], "_agg"))))

#which areas of raster fall within borders?
  assign(paste0(region_names_noshift[i], "_mask"),
       mask(raster_extent, get(paste0(region_names_noshift[i], "_agg"))))
  
  assign(paste0(region_names_noshift[i], "_mask_1s"),
         reclassify(get(paste0(region_names_noshift[i], "_mask")), cbind(-Inf, Inf, 1)))
  

}

#edit for east_pac_spdf_shift and west_pac_spdf_shift
for (i in 1:length(region_names_shift[1:2])) {
#crop bathy layer to LME subset
  raster_extent <-
       crop(etopo_shelf_raster_180, extent(get(paste0(region_names_shift[i], "_agg"))))

#which areas of raster fall within borders?
  assign(paste0(region_names_shift[i], "_mask"),
       mask(raster_extent, get(paste0(region_names_shift[i], "_agg"))))
  
    assign(paste0(region_names_shift[i], "_mask_1s"),
       reclassify(get(paste0(region_names_shift[i], "_mask")), cbind(-Inf, Inf, 1)))

}

```

Splitting raster into many to plot individually

Western Pacific
```{r split raster for western pacific}
north_extent <- c(xmin(west_pac_spdf_shift_mask), xmax(west_pac_spdf_shift_mask), 0, ymax(west_pac_spdf_shift_mask))
south_extent <- c(xmin(west_pac_spdf_shift_mask), xmax(west_pac_spdf_shift_mask), ymin(west_pac_spdf_shift_mask), 0)

#crop into above and below 0
west_pac_spdf_shift_agg_north <- crop(west_pac_spdf_shift_mask, extent(north_extent))
west_pac_spdf_shift_agg_south <- crop(west_pac_spdf_shift_mask, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for west pacific
west_pac_north_latitudes <- seq(0, ymax(west_pac_spdf_shift_mask), by = 0.5)
west_pac_south_latitudes <- seq(-0.5, ymin(west_pac_spdf_shift_mask), by = -0.5)

west_pac_shelf_areas <- as.data.table(matrix(nrow = (length(west_pac_north_latitudes)-1+length(west_pac_south_latitudes)-1)))
                                      
west_pac_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(west_pac_north_latitudes)-1)) {
  north_extent <- c(xmin(west_pac_spdf_shift_mask), xmax(west_pac_spdf_shift_mask), west_pac_north_latitudes[i], west_pac_north_latitudes[i+1])
  segment <- crop(west_pac_spdf_shift_mask, extent(north_extent))
  
  if(all(is.na(values(segment)))) {
    
  west_pac_shelf_areas[i, "latitude_start"] <- west_pac_north_latitudes[i]
  west_pac_shelf_areas[i, "latitude_end"] <- west_pac_north_latitudes[i+1]
  west_pac_shelf_areas[i, "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  west_pac_shelf_areas[i, "latitude_start"] <- west_pac_north_latitudes[i]
  west_pac_shelf_areas[i, "latitude_end"] <- west_pac_north_latitudes[i+1]
  west_pac_shelf_areas[i, "area"] <- segment_area
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(west_pac_south_latitudes)-1)) {
  south_extent <- c(xmin(west_pac_spdf_shift_mask), xmax(west_pac_spdf_shift_mask), west_pac_south_latitudes[i+1], west_pac_south_latitudes[i])
  segment <- crop(west_pac_spdf_shift_mask, extent(south_extent))
  
  if(all(is.na(values(segment)))) {
    
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "latitude_start"] <- west_pac_south_latitudes[i]
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "latitude_end"] <- west_pac_south_latitudes[i+1]
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "latitude_start"] <- west_pac_south_latitudes[i]
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "latitude_end"] <- west_pac_south_latitudes[i+1]
  west_pac_shelf_areas[i+(length(west_pac_north_latitudes)-1), "area"] <- segment_area
  
  print(i)
  } 
}

```

Eastern Pacific

east_pac_spdf_shift

```{r split raster for eastern pacific}
north_extent <- c(xmin(east_pac_spdf_shift_mask), xmax(east_pac_spdf_shift_mask), 0, ymax(east_pac_spdf_shift_mask))
south_extent <- c(xmin(east_pac_spdf_shift_mask), xmax(east_pac_spdf_shift_mask), ymin(east_pac_spdf_shift_mask), 0)

#crop into above and below 0
east_pac_spdf_shift_agg_north <- crop(east_pac_spdf_shift_mask, extent(north_extent))
east_pac_spdf_shift_agg_south <- crop(east_pac_spdf_shift_mask, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east pacific
east_pac_north_latitudes <- seq(0, ymax(east_pac_spdf_shift_mask), by = 0.5)
east_pac_south_latitudes <- seq(-0.5, ymin(east_pac_spdf_shift_mask), by = -0.5)

east_pac_shelf_areas <- as.data.table(matrix(nrow = (length(east_pac_north_latitudes)-1+length(east_pac_south_latitudes)-1)))
                                      
east_pac_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(east_pac_north_latitudes)-1)) {
  north_extent <- c(xmin(east_pac_spdf_shift_mask), xmax(east_pac_spdf_shift_mask), east_pac_north_latitudes[i], east_pac_north_latitudes[i+1])
  segment <- crop(east_pac_spdf_shift_mask, extent(north_extent))
  
  if(all(is.na(values(segment)))) {
    
  east_pac_shelf_areas[i, "latitude_start"] <- east_pac_north_latitudes[i]
  east_pac_shelf_areas[i, "latitude_end"] <- east_pac_north_latitudes[i+1]
  east_pac_shelf_areas[i, "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  east_pac_shelf_areas[i, "latitude_start"] <- east_pac_north_latitudes[i]
  east_pac_shelf_areas[i, "latitude_end"] <- east_pac_north_latitudes[i+1]
  east_pac_shelf_areas[i, "area"] <- segment_area
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(east_pac_south_latitudes)-1)) {
  south_extent <- c(xmin(east_pac_spdf_shift_mask), xmax(east_pac_spdf_shift_mask), east_pac_south_latitudes[i+1], east_pac_south_latitudes[i])
  segment <- crop(east_pac_spdf_shift_mask, extent(south_extent))
  
  if(all(is.na(values(segment)))) {
    
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "latitude_start"] <- east_pac_south_latitudes[i]
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "latitude_end"] <- east_pac_south_latitudes[i+1]
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "latitude_start"] <- east_pac_south_latitudes[i]
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "latitude_end"] <- east_pac_south_latitudes[i+1]
  east_pac_shelf_areas[i+(length(east_pac_north_latitudes)-1), "area"] <- segment_area
  
  print(i)
  } 
}

```

Western Atlantic

west_atl_spdf_mask

```{r split raster for western atlantic}
north_extent <- c(xmin(west_atl_spdf), xmax(west_atl_spdf_mask), 0, ymax(west_atl_spdf_mask))
                  
south_extent <- c(xmin(west_atl_spdf_mask), xmax(west_atl_spdf_mask), ymin(west_atl_spdf_mask), 0)

#crop into above and below 0
west_atl_agg_north <- crop(west_atl_spdf_mask, extent(north_extent))
west_atl_agg_south <- crop(west_atl_spdf_mask, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east pacific
west_atl_north_latitudes <- seq(0, ymax(west_atl_spdf_mask), by = 0.5)
west_atl_south_latitudes <- seq(-0.5, ymin(west_atl_spdf_mask), by = -0.5)

west_atl_shelf_areas <- as.data.table(matrix(nrow = (length(west_atl_north_latitudes)-1+length(west_atl_south_latitudes)-1)))
                                      
west_atl_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(west_atl_north_latitudes)-1)) {
  north_extent <- c(xmin(west_atl_spdf_mask), xmax(west_atl_spdf_mask), west_atl_north_latitudes[i], west_atl_north_latitudes[i+1])
  segment <- crop(west_atl_spdf_mask, extent(north_extent))
  
  if(all(is.na(values(segment)))) {
    
  west_atl_shelf_areas[i, "latitude_start"] <- west_atl_north_latitudes[i]
  west_atl_shelf_areas[i, "latitude_end"] <- west_atl_north_latitudes[i+1]
  west_atl_shelf_areas[i, "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  west_atl_shelf_areas[i, "latitude_start"] <- west_atl_north_latitudes[i]
  west_atl_shelf_areas[i, "latitude_end"] <- west_atl_north_latitudes[i+1]
  west_atl_shelf_areas[i, "area"] <- segment_area
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(west_atl_south_latitudes)-1)) {
  south_extent <- c(xmin(west_atl_spdf_mask), xmax(west_atl_spdf_mask), west_atl_south_latitudes[i+1], west_atl_south_latitudes[i])
  segment <- crop(west_atl_spdf_mask, extent(south_extent))
  
  if(all(is.na(values(segment)))) {
    
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "latitude_start"] <- west_atl_south_latitudes[i]
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "latitude_end"] <- west_atl_south_latitudes[i+1]
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "latitude_start"] <- west_atl_south_latitudes[i]
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "latitude_end"] <- west_atl_south_latitudes[i+1]
  west_atl_shelf_areas[i+(length(west_atl_north_latitudes)-1), "area"] <- segment_area
  
  print(i)
  } 
}

```

Eastern Atlantic

east_atl_spdf_nobuf_mask

```{r split raster for eastern atlantic}
north_extent <- c(xmin(east_atl_spdf_nobuf_mask), xmax(east_atl_spdf_nobuf_mask), 0, ymax(east_atl_spdf_nobuf_mask))
south_extent <- c(xmin(east_atl_spdf_nobuf_mask), xmax(east_atl_spdf_nobuf_mask), ymin(east_atl_spdf_nobuf_mask), 0)

#crop into above and below 0
east_atl_agg_north <- crop(east_atl_spdf_nobuf_mask, extent(north_extent))
east_atl_agg_south <- crop(east_atl_spdf_nobuf_mask, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east pacific
east_atl_north_latitudes <- seq(0, ymax(east_atl_spdf_nobuf_mask), by = 0.5)
east_atl_south_latitudes <- seq(-0.5, ymin(east_atl_spdf_nobuf_mask), by = -0.5)

east_atl_shelf_areas <- as.data.table(matrix(nrow = (length(east_atl_north_latitudes)-1+length(east_atl_south_latitudes)-1)))
                                      
east_atl_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(east_atl_north_latitudes)-1)) {
  north_extent <- c(xmin(east_atl_spdf_nobuf_mask), xmax(east_atl_spdf_nobuf_mask), east_atl_north_latitudes[i], east_atl_north_latitudes[i+1])
  segment <- crop(east_atl_spdf_nobuf_mask, extent(north_extent))
  
  if(all(is.na(values(segment)))) {
    
  east_atl_shelf_areas[i, "latitude_start"] <- east_atl_north_latitudes[i]
  east_atl_shelf_areas[i, "latitude_end"] <- east_atl_north_latitudes[i+1]
  east_atl_shelf_areas[i, "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  east_atl_shelf_areas[i, "latitude_start"] <- east_atl_north_latitudes[i]
  east_atl_shelf_areas[i, "latitude_end"] <- east_atl_north_latitudes[i+1]
  east_atl_shelf_areas[i, "area"] <- segment_area
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(east_atl_south_latitudes)-1)) {
  south_extent <- c(xmin(east_atl_spdf_nobuf_mask), xmax(east_atl_spdf_nobuf_mask), east_atl_south_latitudes[i+1], east_atl_south_latitudes[i])
  segment <- crop(east_atl_spdf_nobuf_mask, extent(south_extent))
  
  if(all(is.na(values(segment)))) {
    
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "latitude_start"] <- east_atl_south_latitudes[i]
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "latitude_end"] <- east_atl_south_latitudes[i+1]
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "latitude_start"] <- east_atl_south_latitudes[i]
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "latitude_end"] <- east_atl_south_latitudes[i+1]
  east_atl_shelf_areas[i+(length(east_atl_north_latitudes)-1), "area"] <- segment_area
  
  print(i)
  } 
}

```

Western Indian

west_ind_spdf_mask

```{r split raster for western indian}
north_extent <- c(xmin(west_ind_spdf_mask), xmax(west_ind_spdf_mask), 0, ymax(west_ind_spdf_mask))
south_extent <- c(xmin(west_ind_spdf_mask), xmax(west_ind_spdf_mask), ymin(west_ind_spdf_mask), 0)

#crop into above and below 0
west_ind_agg_north <- crop(west_ind_spdf_mask, extent(north_extent))
west_ind_agg_south <- crop(west_ind_spdf_mask, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east pacific
west_ind_north_latitudes <- seq(0, ymax(west_ind_spdf_mask), by = 0.5)
west_ind_south_latitudes <- seq(-0.5, ymin(west_ind_spdf_mask), by = -0.5)

west_ind_shelf_areas <- as.data.table(matrix(nrow = (length(west_ind_north_latitudes)-1+length(west_ind_south_latitudes)-1)))
                                      
west_ind_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(west_ind_north_latitudes)-1)) {
  north_extent <- c(xmin(west_ind_spdf_mask), xmax(west_ind_spdf_mask), west_ind_north_latitudes[i], west_ind_north_latitudes[i+1])
  segment <- crop(west_ind_spdf_mask, extent(north_extent))
  
  if(all(is.na(values(segment)))) {
    
  west_ind_shelf_areas[i, "latitude_start"] <- west_ind_north_latitudes[i]
  west_ind_shelf_areas[i, "latitude_end"] <- west_ind_north_latitudes[i+1]
  west_ind_shelf_areas[i, "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  west_ind_shelf_areas[i, "latitude_start"] <- west_ind_north_latitudes[i]
  west_ind_shelf_areas[i, "latitude_end"] <- west_ind_north_latitudes[i+1]
  west_ind_shelf_areas[i, "area"] <- segment_area
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(west_ind_south_latitudes)-1)) {
  south_extent <- c(xmin(west_ind_spdf_mask), xmax(west_ind_spdf_mask), west_ind_south_latitudes[i+1], west_ind_south_latitudes[i])
  segment <- crop(west_ind_spdf_mask, extent(south_extent))
  
  if(all(is.na(values(segment)))) {
    
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "latitude_start"] <- west_ind_south_latitudes[i]
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "latitude_end"] <- west_ind_south_latitudes[i+1]
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "latitude_start"] <- west_ind_south_latitudes[i]
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "latitude_end"] <- west_ind_south_latitudes[i+1]
  west_ind_shelf_areas[i+(length(west_ind_north_latitudes)-1), "area"] <- segment_area
  
  print(i)
  } 
}

```


Eastern Indian

east_ind_spdf_mask

```{r split raster for eastern indian}
north_extent <- c(xmin(east_ind_spdf_mask), xmax(east_ind_spdf_mask), 0, ymax(east_ind_spdf_mask))
south_extent <- c(xmin(east_ind_spdf_mask), xmax(east_ind_spdf_mask), ymin(east_ind_spdf_mask), 0)

#crop into above and below 0
east_ind_agg_north <- crop(east_ind_spdf_mask, extent(north_extent))
east_ind_agg_south <- crop(east_ind_spdf_mask, extent(south_extent))

#unfortunately, I think I may have to just do this manually (ugly, I know)

#all chunks for east pacific
east_ind_north_latitudes <- seq(0, ymax(east_ind_spdf_mask), by = 0.5)
east_ind_south_latitudes <- seq(-0.5, ymin(east_ind_spdf_mask), by = -0.5)

east_ind_shelf_areas <- as.data.table(matrix(nrow = (length(east_ind_north_latitudes)-1+length(east_ind_south_latitudes)-1)))
                                      
east_ind_shelf_areas[, latitude_start := as.numeric(V1)][, latitude_end := as.numeric(V1)][, area := as.numeric(V1)][, V1 := NULL]

#loop for north
for (i in 1:(length(east_ind_north_latitudes)-1)) {
  north_extent <- c(xmin(east_ind_spdf_mask), xmax(east_ind_spdf_mask), east_ind_north_latitudes[i], east_ind_north_latitudes[i+1])
  segment <- crop(east_ind_spdf_mask, extent(north_extent))
  
  if(all(is.na(values(segment)))) {
    
  east_ind_shelf_areas[i, "latitude_start"] <- east_ind_north_latitudes[i]
  east_ind_shelf_areas[i, "latitude_end"] <- east_ind_north_latitudes[i+1]
  east_ind_shelf_areas[i, "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  east_ind_shelf_areas[i, "latitude_start"] <- east_ind_north_latitudes[i]
  east_ind_shelf_areas[i, "latitude_end"] <- east_ind_north_latitudes[i+1]
  east_ind_shelf_areas[i, "area"] <- segment_area
  
  print(i)
  } 
}

#loop for south
for (i in 1:(length(east_ind_south_latitudes)-1)) {
  south_extent <- c(xmin(east_ind_spdf_mask), xmax(east_ind_spdf_mask), east_ind_south_latitudes[i+1], east_ind_south_latitudes[i])
  segment <- crop(east_ind_spdf_mask, extent(south_extent))
  
  if(all(is.na(values(segment)))) {
    
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "latitude_start"] <- east_ind_south_latitudes[i]
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "latitude_end"] <- east_ind_south_latitudes[i+1]
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area"] <- 0
  
  print(i)
    
  } else {
  #get sizes of all cells in raster [km2]
    cell_size<-area(segment, na.rm=TRUE, weights=FALSE)
    #delete NAs from vector of all raster cells
    ##NAs lie outside of the rastered region, can thus be omitted
    cell_size<-cell_size[!is.na(segment)]
    #compute area [km2] of all cells in geo_raster
    segment_area <-length(cell_size)*median(cell_size)

  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "latitude_start"] <- east_ind_south_latitudes[i]
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "latitude_end"] <- east_ind_south_latitudes[i+1]
  east_ind_shelf_areas[i+(length(east_ind_north_latitudes)-1), "area"] <- segment_area
  
  print(i)
  } 
}

save(east_ind_shelf_areas, west_ind_shelf_areas, east_atl_shelf_areas, west_atl_shelf_areas, east_pac_shelf_areas, west_pac_shelf_areas ,file = "shelf_areas_by_0.5latitude.RData")

```

Plots of latitude versus habitat availability

```{r plots latitude habitat availability}
area_latitude_east_ind <- ggplot(east_ind_shelf_areas, aes(latitude_start, area)) +
  geom_point(shape =18) + 
  geom_line() +
  labs(x = "Latitude", y = "Area (km^2)") +
  annotate("text", x =25, y = 100000, label = "Eastern Indian Ocean") +
  geom_vline(xintercept = 0) +
  
  coord_flip() +
  theme_classic()

  ggsave(area_latitude_east_ind, filename = "area_latitude_east_ind.jpg")

area_latitude_west_ind  <- ggplot(west_ind_shelf_areas, aes(latitude_start, area)) +
  geom_point(shape = 18) + 
  geom_line() +
  labs(x = "Latitude", y = "Area (km^2)") +
  annotate("text", x = 35, y = 45000, label = "Western Indian Ocean") +
  geom_vline(xintercept = 0) +
  coord_flip() +
  theme_classic()

  ggsave(area_latitude_west_ind, filename = "area_latitude_west_ind.jpg")

area_latitude_west_atl  <- ggplot(west_atl_shelf_areas, aes(latitude_start, area)) +
  geom_point(shape =18) + 
  geom_line() +
  labs(x = "Latitude", y = "Area (km^2)") +
  annotate("text", x = 90, y = 170000, label = "Western Atlantic Ocean") +
  geom_vline(xintercept = 0) +
  coord_flip() +
  theme_classic()

  ggsave(area_latitude_west_atl, filename = "area_latitude_west_atl.jpg")

area_latitude_east_atl  <- ggplot(east_atl_shelf_areas, aes(latitude_start, area)) +
  geom_point(shape =18) + 
  geom_line() +
  labs(x = "Latitude", y = "Area (km^2)") +
  annotate("text", x = 90, y = 150000, label = "Eastern Atlantic Ocean") +
  geom_vline(xintercept = 0) +
  coord_flip() +
  theme_classic()

  ggsave(area_latitude_east_atl, filename = "area_latitude_east_atl.jpg")

area_latitude_east_pac  <- ggplot(east_pac_shelf_areas, aes(latitude_start, area)) +
  geom_point(shape =18) + 
  geom_line() +
  labs(x = "Latitude", y = "Area (km^2)") +
  annotate("text", x = 90, y = 170000, label = "Eastern Pacific Ocean") +
  geom_vline(xintercept = 0) +
  coord_flip() +
  theme_classic()

  ggsave(area_latitude_east_pac, filename = "area_latitude_east_pac.jpg")

area_latitude_west_pac <- ggplot(west_pac_shelf_areas, aes(latitude_start, area)) +
  geom_point(shape =18) + 
  geom_line() +
  labs(x = "Latitude", y = "Area (km^2)") +
  annotate("text", x = 90, y = 170000, label = "Western Pacific Ocean") +
  geom_vline(xintercept = 0) +
  coord_flip() +
  theme_classic()

  ggsave(area_latitude_west_pac, filename = "area_latitude_west_pac.jpg")

```

Now, I should make maps for each of these regions

Used https://gist.github.com/valentinitnelav/c7598fcfc8e53658f66feea9d3bafb40 for instructions

```{r setup world maps}
library(ggspatial)

  world <- ne_countries(scale = "medium", returnclass = "sf")

# ~~~~~~~~~~~ Download shapefile from www.naturalearthdata.com ~~~~~~~~~~~ #
# Download countries data
download.file(url = "http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/cultural/ne_110m_admin_0_countries.zip", 
              destfile = "ne_110m_admin_0_countries.zip")
# unzip the shapefile in the directory mentioned with "exdir" argument
unzip(zipfile="ne_110m_admin_0_countries.zip", exdir = "ne_110m_admin_0_countries")
# delete the zip file
file.remove("ne_110m_admin_0_countries.zip")
# read the shapefile with readOGR from rgdal package
NE_countries <- readOGR(dsn = "ne_110m_admin_0_countries", layer = "ne_110m_admin_0_countries")
class(NE_countries) # is a SpatialPolygonsDataFrame object

# ~~~~~~~~~~~ Split world map by "split line" ~~~~~~~~~~~ #

# shift central/prime meridian towards west – positive values only
shift <- 180 +30

# create "split line" to split country polygons
WGS84 <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
split.line <- SpatialLines(list(Lines(list(Line(cbind(180-shift,c(-90,90)))), ID="line")), 
                          proj4string=WGS84)

# NOTE - in case of TopologyException' errors when intersecting line with country polygons,
# apply the gBuffer solution suggested at:
# http://gis.stackexchange.com/questions/163445/r-solution-for-topologyexception-input-geom-1-is-invalid-self-intersection-er
NE_countries <- gBuffer(NE_countries, byid=TRUE, width=0)

# intersecting line with country polygons
line.gInt <- gIntersection(split.line, NE_countries)

# create a very thin polygon (buffer) out of the intersecting "split line"
bf <- gBuffer(line.gInt, byid=TRUE, width=0.000001)  

# split country polygons using intersecting thin polygon (buffer)
NE_countries.split <- gDifference(NE_countries, bf, byid=TRUE)
# plot(NE_countries.split) # check map
class(NE_countries.split) # is a SpatialPolygons object

# ~~~~~~~~~~~ Create graticules ~~~~~~~~~~~ #
# create a bounding box - world extent
b.box <- as(raster::extent(-180, 180, -90, 90), "SpatialPolygons")
# assign CRS to box
proj4string(b.box) <- WGS84
# create graticules/grid lines from box
grid <- gridlines(b.box, 
                  easts  = seq(from=-180, to=180, by=20),
                  norths = seq(from=-90, to=90, by=10))

# create labels for graticules
grid.lbl <- labels(grid, side = 1:4)

# transform labels from SpatialPointsDataFrame to a data table that ggplot can use
grid.lbl.DT <- data.table(grid.lbl@coords, grid.lbl@data)

# prepare labels with regular expression:
# - delete unwanted labels
grid.lbl.DT[, labels := gsub(pattern="180\\*degree|90\\*degree\\*N|90\\*degree\\*S", replacement="", x=labels)]
# - replace pattern "*degree" with "°" (* needs to be escaped with \\)
grid.lbl.DT[, lbl := gsub(pattern="\\*degree", replacement="°", x=labels)]
# - delete any remaining "*"
grid.lbl.DT[, lbl := gsub(pattern="*\\*", replacement="", x=lbl)]

# adjust coordinates of labels so that they fit inside the globe
grid.lbl.DT[, long := ifelse(coords.x1 %in% c(-180,180), coords.x1*175/180, coords.x1)]
grid.lbl.DT[, lat  := ifelse(coords.x2 %in% c(-90,90), coords.x2*82/90, coords.x2)]

# ~~~~~~~~~~~ Prepare data for ggplot, shift & project coordinates ~~~~~~~~~~~ #
# give the PORJ.4 string for Eckert IV projection ( changed to different projection, "+proj=eck4 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs" for eckert)
PROJ <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0" 

# transform graticules from SpatialLines to a data table that ggplot can use
grid.DT <- data.table(map_data(SpatialLinesDataFrame(sl=grid, 
                                                     data=data.frame(1:length(grid)), 
                                                     match.ID = FALSE)))
# project coordinates
# assign matrix of projected coordinates as two columns in data table
grid.DT[, c("X","Y") := data.table(project(cbind(long, lat), proj=PROJ))]

# project coordinates of labels
grid.lbl.DT[, c("X","Y") := data.table(project(cbind(long, lat), proj=PROJ))]

# transform split country polygons in a data table that ggplot can use
Country.DT_shift <- data.table(map_data(as(NE_countries.split, "SpatialPolygonsDataFrame")))
Country.DT <- data.table(map_data(as(NE_countries, "SpatialPolygonsDataFrame")))
# Shift coordinates
Country.DT_shift[, long.new := long + shift]
Country.DT_shift[, long.new := ifelse(long.new > 180, long.new-360, long.new)]

# project coordinates 
Country.DT[, c("X","Y") := data.table(project(cbind(long, lat), proj=PROJ))]
Country.DT_shift[, c("X","Y") := data.table(project(cbind(long.new, lat), proj=PROJ))]

# ~~~~~~~~~~~ Plot map ~~~~~~~~~~~ #
ggplot() + 
    # add projected countries
    geom_polygon(data = Country.DT_shift, 
                 aes(x = long.new+150, y = lat, group = group), 
                 colour = "gray70", 
                 fill = "gray90", 
                 size = 0.25) +
    # add graticules
    geom_path(data = grid.DT, 
              aes(x = X, y = Y, group = group), 
              linetype = "dotted", colour = "grey50", size = .25) +
    # add a bounding box (select graticules at edges)
    geom_path(data = grid.DT[(long %in% c(-180,180) & region == "NS")
                             |(long %in% c(-180,180) & lat %in% c(-90,90) & region == "EW")], 
              aes(x = X, y = Y, group = group), 
              linetype = "solid", colour = "black", size = .3) +
    # add graticule labels
    geom_text(data = grid.lbl.DT, # latitude
              aes(x = X, y = Y, label = lbl), 
              colour = "grey50", size = 2) +
    # ensures that one unit on the x-axis is the same length as one unit on the y-axis
    coord_equal() + # same as coord_fixed(ratio = 1)
    # set empty theme
    theme_void()

```

```{r mapping each region}

region_maps <- list()
regions_shift_projection <- c("west_pac_spdf_shift", "east_pac_spdf_shift", "west_atl_spdf")

for (i in 1:length(region_names)) {
  
  region_spdf <- get(paste0(region_names[i], "_mask"))
  
  ifelse(region_names[i] %in% regions_shift_projection,
  
  #pacific centered projection
  
  region_spdf_mask_1s_extent <- extent(get(paste0(region_names[i],"_mask_1s"))) # take extent of region
  
  #convert rasters to dfs data frame
  region_spdf <- as(get(paste0(region_names[i],"_mask_1s")), "SpatialPixelsDataFrame")
  region_df <- as.data.frame(region_spdf)
  colnames(region_df) <- c("value", "x", "y")
  
  
  (region_maps[[i]] <- ggplot() + 
    # add projected countries
    geom_polygon(data = Country.DT_shift, 
                 aes(x = long.new+150, y = lat, group = group), 
                 colour = "gray70", 
                 fill = "gray90", 
                 size = 0.25) +
    geom_tile(data = region_df, aes(x = x, y = y, fill = value), color = "seagreen4") +
    coord_sf(x = c(region_spdf_mask_1s_extent[1], region_spdf_mask_1s_extent[2]), y = c(region_spdf_mask_1s_extent[3], region_spdf_mask_1s_extent[4])) +
    labs( x = "Longitude (˚E)", y = "Latitude (˚N)") +
    geom_abline(intercept = 0, slope = 0) +
    theme_classic() +
    theme(legend.position = "none"))
  
  filename <- paste0(region_names[i], "_map.jpg")
  ggsave(plot = region_maps[[i]], filename = filename)
  
,
  #atlantic centered projection
  region_spdf_mask_1s_extent <- extent(get(paste0(region_names[i],"_mask_1s"))) # take extent of region
  
  #convert rasters to dfs data frame
  region_spdf <- as(get(paste0(region_names[i],"_mask_1s")), "SpatialPixelsDataFrame")
  region_df <- as.data.frame(region_spdf)
  colnames(region_df) <- c("value", "x", "y")
  
  
  (region_maps[[i]] <- ggplot() + 
    # add projected countries
    geom_polygon(data = Country.DT, 
                 aes(x = long, y = lat, group = group), 
                 colour = "gray70", 
                 fill = "gray90", 
                 size = 0.25) +
    geom_tile(data = region_df, aes(x = x, y = y, fill = value), color = "seagreen4") +
    coord_sf(x = c(region_spdf_mask_1s_extent[1], region_spdf_mask_1s_extent[2]), y = c(region_spdf_mask_1s_extent[3], region_spdf_mask_1s_extent[4])) +
    labs( x = "Longitude (˚E)", y = "Latitude (˚N)") +
    geom_abline(intercept = 0, slope = 0) +
    theme_classic() +
    theme(legend.position = "none"))
  
  filename <- paste0(region_names[i], "_map.jpg")
  ggsave(plot = region_maps[[i]], filename = filename)
  

  )
  }
```

