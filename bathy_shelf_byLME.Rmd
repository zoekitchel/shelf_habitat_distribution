---
title: "Starting with Bathy for Shelves"
output: html_notebook
---

```{r setup}
library(raster)
library(rgdal)
library(sf)
library(ncdf4)
library(rmapshaper)
library(tidyverse)
library(diptest)
library(moments)
library(viridis) #colors
library(data.table)
library(hydroTSM) #hypsometric curves

etopo_shelf_df <- readRDS("~/Documents/grad school/Rutgers/Repositories/shelf_habitat_distribution/etopo_shelf_df.rds")
#bring in bathy for shelf regions

#LMEs
LME_spdf <- readOGR("LME66/LMEs66.shp")
head(LME_spdf)
```

Let's just start with one LME to get started
```{r LME_baltic}
LME_baltic <- LME_spdf[1,]
plot(LME_baltic)


```


Make bathy layer into raster
```{r rasterize}
proj <- crs(LME_spdf)
etopo_shelf_raster <- rasterFromXYZ(etopo_shelf_df, crs = proj)

#make figure of shelves
png("etopo_shelf_bathy.png", height=5, width=7, units="in", res=300)
plot(etopo_shelf_raster)
dev.off()

```

Clip raster to each individual polygon

```{r clip raster to polygon}
#crop bathy layer to LME subset
bathy_baltic_extent <- crop(etopo_shelf_raster, extent(LME_baltic))

#which areas of raster fall within borders?
bathy_baltic_mask <- mask(bathy_baltic_extent, LME_baltic)

#convert to df for plotting

  # First, to a SpatialPointsDataFrame
  bathy_baltic_pts <- rasterToPoints(bathy_baltic_mask, spatial = TRUE)
  # Then to a 'conventional' dataframe
  bathy_baltic_dt  <- data.table(data.frame(bathy_baltic_pts))

#keep depth positive  
bathy_baltic_dt[,depth := -(layer)]

#fortify to plot shapefile on top
#LME_baltic_df <- fortify(LME_baltic) (don't need because indstead I make polygon to surround raster)

#To get a polygon that surrounds cells that are not NA

  # make all values the same.
  r <- reclassify(bathy_baltic_mask, cbind(-Inf, Inf, 1))
  
  # convert to polygons (you need to have package 'rgeos' installed for this to work)
  pp <- rasterToPolygons(r, dissolve=TRUE)
  
  LME_reduced_baltic_df <- fortify(pp)

ggplot(bathy_baltic_dt) +
  geom_tile(aes(x = x, y = y, fill = depth)) +
  scale_fill_viridis(direction = -1) +
  theme_classic() +
  labs(x = "Longitude", y = "Latitude", fill = "Depth (m)") +
  guides(fill = guide_colorbar(reverse = T)) +
  geom_path(data = LME_reduced_baltic_df, aes(x = long, y = lat, group = group), fill = NA, color = "black")

summary(bathy_baltic_dt)

#how to get area of raster

  #get sizes of all cells in raster [km2]
  cell_size<-area(bathy_baltic_mask, na.rm=TRUE, weights=FALSE)
  #delete NAs from vector of all raster cells
  ##NAs lie outside of the rastered region, can thus be omitted
  cell_size<-cell_size[!is.na(cell_size)]
  #compute area [km2] of all cells in geo_raster
  bathy_raster_area<-length(cell_size)*median(cell_size)

```

Hypsometric Curves
```{r hyposometric curves}

bathy_baltic_SGDF <- as(bathy_baltic_mask, 'SpatialGridDataFrame') # as spatial grid data frame
hypsometric(bathy_baltic_SGDF)

#dimensions of raster?
dim(bathy_baltic_mask)

#total number of cells?
cells <- dim(bathy_baltic_mask)[1]*dim(bathy_baltic_mask)[2]


#cells of each depth value in data table
bathy_baltic_bydepth <- data.table(freq(bathy_baltic_mask))

#NA cells
na_cell_count <- bathy_baltic_bydepth[is.na(value),]$count

#filled cells

cells_filled <- cells-na_cell_count

bathy_baltic_bydepth_complete <- bathy_baltic_bydepth[!is.na(value)]

#calculate percent of total area in polygon
bathy_baltic_bydepth_complete[,percent_area := count/sum(count)]


bathy_baltic_bydepth_complete[,area := percent_area*bathy_raster_area][,depth := -value]



(plot <- ggplot(data = bathy_baltic_bydepth_complete, aes(x = depth, y = area, fill = depth)) +
  geom_col(width = 1) +
  theme_classic() +
  labs(x = "Depth (m)", y = "Area (km^2)", fill = "Depth (m)") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_fill_gradientn(colors = rev(viridis(5)), limits = c(0, 2000)) +
  guides(position = "bottom", fill = guide_colorbar(reverse = T)))

ggsave(plot, filename = "Baltic_Sea.png")
```


How to classify different LMES? Dip (Modality) & Skew
 "distributions with a dip value >0.01 and with significant (p<0.05) deviations from unimodality to the hourglass classification. 
 
 For distributions with a dip value ≤0.01, we assigned those with a Type-I skewness ≥0.5 to pyramid, 
 
 those with skewness ≤ −0.5 to inverse pyramid, 
 
 and the remainder to diamond, representing those with approximately normal distributions. 
 
 We chose skew cutoffs of 0.5 and −0.5 to capture right- and left-skewed distributions, respectively, and to bound distributions approximating symmetry."
 
Modality: In mathematics, unimodality means possessing a unique mode. More generally, unimodality means there is only a single highest value, somehow defined, of some mathematical object. (Wikipedia)

Skew: In probability theory and statistics, skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean. The skewness value can be positive, zero, negative, or undefined. (Wikipedia)
 
```{r dip test for unimodality}
#Computes Hartigans’ dip test statistic for testing unimodality, and additionally the modal interval.

diptest <- dip.test(bathy_baltic_bydepth_complete$depth, simulate.p.value = FALSE, B = 2000)
p.value <- diptest$p.value

```

Skew

* If skewness is less than -1 or greater than 1, the distribution is highly skewed.
* If skewness is between -1 and -0.5 or between 0.5 and 1, the distribution is moderately skewed.
* If skewness is between -0.5 and 0.5, the distribution is approximately symmetric.
```{r skew}
skew <- skewness(bathy_baltic_bydepth_complete$depth, na.rm = T)
```


Maybe kurtosis too?

Kurtosis is a statistical measure that defines how heavily the tails of a distribution differ from the tails of a normal distribution. In other words, kurtosis identifies whether the tails of a given distribution contain extreme values.
```{r kurtosis}
kurtosis <- kurtosis(bathy_baltic_bydepth_complete$depth, na.rm = T)
```

Mean depth value
```{r mean depth}
mean <- mean(bathy_baltic_bydepth_complete$depth)
```

Maybe then do a MDS including kurtosis, skew, and modality measures for every LME

See how many groups it goes into?

Shallow dominant: High positive skew, unimodal
Mid-Dominant: Relatively normal (low skew, kurtosis = 0, unimodal)
Deep-Dominant: High negative skew, unimodal
Uniform: kurtosis < -1.2, unimodal, little skew
Hourglass: Bimodality

Text to add to plot:
 - class
 - skew
 - dip
 - mean
 - bottleneck

```{r full plot}

plot +
  annotate("text", x = 300, y = 4000, label = paste0("Dip Test: ", signif(diptest$statistic,2), " P-value = ", signif(p.value))) +
  annotate("text", x = 300, y = 3700, label = paste0("Skew: ", round(skew,2))) +
  annotate("text", x = 300, y = 3400, label = paste0("Kurtosis: ",round(kurtosis,2))) +
  annotate("text", x = 300, y = 3100, label = paste0("Mean: ",round(mean,2), " m")) +
  geom_vline(xintercept = mean, color = "red")
```

--------
Now let's make a loop!!

```{r loop}
#subset by LME

LMEs <- LME_spdf$LME_NUMBER

#plot map, plot hypsograph, plot histogram

LME_bathymetry <- data.table(dip_test, skew, kurtosis, mean_elev, bottleneck, elev)

for i in length(1:length(LMEs)) {
LME_single <- LME_spdf[i,]

#clip raster to LME
LME_extent <- crop(etopo_shelf_raster, extent(LME_single))

#which areas of raster fall within borders?
LME_mask <- mask(LME_extent, LME_single)

#conver to df for plotting
  # First, to a SpatialPointsDataFrame
  LME_points <- rasterToPoints(LME_mask, spatial = TRUE)
  # Then to a 'conventional' dataframe
  LME_dt  <- data.table(data.frame(LME_points))

#keep depth positive  
LME_dt[,depth := -(layer)]

#size of raster  
#get sizes of all cells in raster [km2]
  cell_size<-area(LME_mask, na.rm=TRUE, weights=FALSE)
  #delete NAs from vector of all raster cells
  ##NAs lie outside of the rastered region, can thus be omitted
  cell_size<-cell_size[!is.na(cell_size)]
  #compute area [km2] of all cells in geo_raster
  bathy_raster_area<-length(cell_size)*median(cell_size)
  
#To get a polygon that surrounds cells that are not NA

  # make all values the same.
  r <- reclassify(LME_mask, cbind(-Inf, Inf, 1))
  
  # convert to polygons (you need to have package 'rgeos' installed for this to work)
  pp <- rasterToPolygons(r, dissolve=TRUE)
  
  LME_reduced_df <- fortify(pp)

ggplot(LME_dt) +
  geom_tile(aes(x = x, y = y, fill = depth)) +
  scale_fill_viridis(direction = -1) +
  theme_classic() +
  labs(x = "Longitude", y = "Latitude", fill = "Depth (m)") +
  guides(fill = guide_colorbar(reverse = T)) +
  geom_path(data = LME_reduced_df, aes(x = long, y = lat, group = group), fill = NA, color = "black")

#cells of each depth value in data table
LME_bathy_bydepth <- data.table(freq(LME_mask))

LME_bathy_bydepth_complete <- LME_bathy_bydepth[!is.na(value)]

#calculate percent of total area in polygon
LME_bathy_bydepth_complete[,percent_area := count/sum(count)]


LME_bathy_bydepth_complete[,area := percent_area*raster_area][,depth := -value]



(plot <- ggplot(data = LME_bathy_bydepth_complete, aes(x = depth, y = area, fill = depth)) +
  geom_col(width = 1) +
  theme_classic() +
  labs(x = "Depth (m)", y = "Area (km^2)", fill = "Depth (m)") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_fill_gradientn(colors = rev(viridis(5)), limits = c(0, 2000)) +
  guides(position = "bottom", fill = guide_colorbar(reverse = T)))

ggsave(plot, filename = "LME_2.png")

#unimodality
#Computes Hartigans’ dip test statistic for testing unimodality, and additionally the modal interval.

diptest <- dip.test(LME_bathy_bydepth_complete$depth, simulate.p.value = FALSE, B = 2000)
p.value <- diptest$p.value
skew <- skewness(LME_bathy_bydepth_complete$depth, na.rm = T)
kurtosis <- kurtosis(LME_bathy_bydepth_complete$depth, na.rm = T)
mean <- mean(LME_bathy_bydepth_complete$depth)

#full plot
plot +
  annotate("text", x=Inf, y = Inf, vjust=1, hjust=1, label = paste0("Dip Test: ", signif(diptest$statistic,2), " P-value = ", signif(p.value))) +
  annotate("text", x=Inf, y = Inf, vjust=1, hjust=0.9, label = paste0("Skew: ", round(skew,2))) +
  annotate("text", x=Inf, y = Inf, vjust=1, hjust=0.8, label = paste0("Kurtosis: ",round(kurtosis,2))) +
  annotate("text", x=Inf, y = Inf, vjust=1, hjust=0.7, label = paste0("Mean: ",round(mean,2), " m")) +
  geom_vline(xintercept = mean, color = "red")

}
```

